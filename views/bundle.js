/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./views/client/Client.ts":
/*!********************************!*\
  !*** ./views/client/Client.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Connection_1 = __importDefault(__webpack_require__(/*! ./Connection/Connection */ \"./views/client/Connection/Connection.ts\"));\r\nconst Logger_1 = __importDefault(__webpack_require__(/*! ./Utils/Logger */ \"./views/client/Utils/Logger.ts\"));\r\nconst ElementManager_1 = __importDefault(__webpack_require__(/*! ./Rendering/ElementManager */ \"./views/client/Rendering/ElementManager.ts\"));\r\nconst CanvasManager_1 = __importDefault(__webpack_require__(/*! ./Rendering/CanvasManager */ \"./views/client/Rendering/CanvasManager.ts\"));\r\nconst Player_1 = __importDefault(__webpack_require__(/*! ./Entity/Player */ \"./views/client/Entity/Player.ts\"));\r\n/** A representation of the client currently on the site. */\r\nclass Client {\r\n    constructor() {\r\n        /** The logging system in the IOStream. */\r\n        this.logger = Logger_1.default;\r\n        /** The player information of the client. */\r\n        this.player = new Player_1.default();\r\n        /** The connection between the client and the server. */\r\n        this.connection = new Connection_1.default(this, \"ws://localhost:8080\");\r\n        /** The DOM element manager. */\r\n        this.elements = new ElementManager_1.default(this);\r\n        /** The canvas on which the client draws on. */\r\n        this.canvas = new CanvasManager_1.default(this);\r\n    }\r\n}\r\nexports[\"default\"] = Client;\r\n;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Client.ts?");

/***/ }),

/***/ "./views/client/Connection/Connection.ts":
/*!***********************************************!*\
  !*** ./views/client/Connection/Connection.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst SwiftStream_1 = __importDefault(__webpack_require__(/*! ./SwiftStream */ \"./views/client/Connection/SwiftStream.ts\"));\r\nconst Enums_1 = __webpack_require__(/*! ../Const/Enums */ \"./views/client/Const/Enums.ts\");\r\nconst MessageHandler_1 = __importDefault(__webpack_require__(/*! ./MessageHandler */ \"./views/client/Connection/MessageHandler.ts\"));\r\n/** A representation of the WebSocket connection between the client and the server. */\r\nclass Connection extends EventTarget {\r\n    constructor(client, url) {\r\n        super();\r\n        /** The amount of retries attempted. */\r\n        this.retries = 0;\r\n        /** The binary encoder/decoder for the connection. */\r\n        this.SwiftStream = new SwiftStream_1.default();\r\n        /** The handler for incoming messages. */\r\n        this.MessageHandler = new MessageHandler_1.default(this);\r\n        this.client = client;\r\n        this.socket = new WebSocket(url);\r\n        this.socket.binaryType = \"arraybuffer\";\r\n        this.handle();\r\n    }\r\n    migrate(url) {\r\n        if (++this.retries > 3)\r\n            return this.client.logger.err(\"[WS]: Threshold for retries has been exceeded. Please reload.\");\r\n        this.socket.close(4999);\r\n        this.socket = new WebSocket(url);\r\n        this.socket.binaryType = \"arraybuffer\";\r\n        this.handle();\r\n    }\r\n    send(header, data) {\r\n        if (this.socket.readyState !== WebSocket.OPEN\r\n            || (!this.client.player.alive && header !== Enums_1.ServerBound.Spawn))\r\n            return;\r\n        this.SwiftStream.WriteI8(header);\r\n        switch (header) {\r\n            case Enums_1.ServerBound.Spawn: {\r\n                this.socket.send(this.SwiftStream\r\n                    .WriteCString(data.name)\r\n                    .WriteI8(this.client.player.character)\r\n                    .WriteI8(this.client.player.ability)\r\n                    .Write());\r\n                break;\r\n            }\r\n            case Enums_1.ServerBound.Movement: {\r\n                data.keys.forEach((key) => this.SwiftStream.WriteI8(key));\r\n                this.socket.send(this.SwiftStream.Write());\r\n                break;\r\n            }\r\n            case Enums_1.ServerBound.Angle: {\r\n                this.socket.send(this.SwiftStream.WriteFloat32(data.measure).Write());\r\n                break;\r\n            }\r\n            case Enums_1.ServerBound.Attack: {\r\n                this.socket.send(this.SwiftStream.WriteI8(data.isAtk).Write());\r\n                break;\r\n            }\r\n            default: {\r\n                this.SwiftStream.Write();\r\n                throw new Error(\"Could not find header. \" + header);\r\n            }\r\n        }\r\n    }\r\n    handle() {\r\n        this.socket.addEventListener(\"open\", () => {\r\n            this.client.logger.success(\"[WS]: Connected to server.\");\r\n        });\r\n        this.socket.addEventListener(\"error\", () => {\r\n            this.client.logger.err(\"[WS]: Connection to server has failed.\");\r\n            this.migrate(this.socket.url);\r\n        });\r\n        this.socket.addEventListener(\"close\", event => {\r\n            if (event.code === 4999)\r\n                return; // Internal migration code.\r\n            this.client.elements.homescreen.homescreen.style.display =\r\n                this.client.elements.arena.game.style.display = \"none\";\r\n            this.client.canvas.phase = Enums_1.Phases.Homescreen;\r\n            this.client.elements.disconnect.disconnect.style.display = \"block\";\r\n            this.client.logger.err(\r\n            /** @ts-ignore */\r\n            this.client.elements.disconnect.disconnectMessage.innerText = Enums_1.CloseEvents[event.code] || Enums_1.CloseEvents[3006]);\r\n        });\r\n        this.socket.addEventListener(\"message\", ({ data }) => {\r\n            this.SwiftStream.Set(data = new Uint8Array(data));\r\n            this.parse();\r\n        });\r\n    }\r\n    parse() {\r\n        const SwiftStream = this.SwiftStream;\r\n        const header = SwiftStream.ReadI8();\r\n        switch (header) {\r\n            case Enums_1.ClientBound.Update:\r\n                this.MessageHandler.Update();\r\n                break;\r\n            default: {\r\n                this.SwiftStream.Clear();\r\n                throw new Error(\"Could not parse packet. \" + header);\r\n            }\r\n        }\r\n        this.SwiftStream.Clear();\r\n    }\r\n}\r\nexports[\"default\"] = Connection;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Connection/Connection.ts?");

/***/ }),

/***/ "./views/client/Connection/Helpers/UpdateParser.ts":
/*!*********************************************************!*\
  !*** ./views/client/Connection/Helpers/UpdateParser.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Enums_1 = __webpack_require__(/*! ../../Const/Enums */ \"./views/client/Const/Enums.ts\");\r\nconst Box_1 = __importDefault(__webpack_require__(/*! ../../Entity/Box */ \"./views/client/Entity/Box.ts\"));\r\nconst Logger_1 = __importDefault(__webpack_require__(/*! ../../Utils/Logger */ \"./views/client/Utils/Logger.ts\"));\r\nconst SwiftStream_1 = __importDefault(__webpack_require__(/*! ../SwiftStream */ \"./views/client/Connection/SwiftStream.ts\"));\r\nclass UpdateParser {\r\n    constructor(connection) {\r\n        /** The packet being handled. */\r\n        this.packet = new SwiftStream_1.default();\r\n        /** The map which parses fields. */\r\n        /** @ts-ignore */\r\n        this.fieldMap = new Map([\r\n            [Enums_1.Fields.ID, (entity) => {\r\n                    const id = this.packet.ReadI8();\r\n                    entity.id = id;\r\n                }],\r\n            [Enums_1.Fields.Position, (entity) => {\r\n                    const x = this.packet.ReadFloat32();\r\n                    const y = this.packet.ReadFloat32();\r\n                    entity.position.target = { x, y };\r\n                }],\r\n            [Enums_1.Fields.Attacking, (entity) => {\r\n                    const attacking = this.packet.ReadI8() === 0x01;\r\n                    entity.attack.attacking.change = attacking;\r\n                    if (!entity.attack.attacking.server && entity.attack.attacking.change)\r\n                        entity.attack.attacking.server = true;\r\n                }],\r\n            [Enums_1.Fields.Weapons, (entity) => {\r\n                    const weapon = this.packet.ReadI8();\r\n                    entity.weapon = weapon;\r\n                }],\r\n            [Enums_1.Fields.FOV, (entity) => {\r\n                    const fov = this.packet.ReadFloat32();\r\n                    entity.fov = fov;\r\n                }],\r\n            [Enums_1.Fields.Dimensions, (entity) => {\r\n                    const width = this.packet.ReadFloat32();\r\n                    const height = this.packet.ReadFloat32();\r\n                    entity.dimensions = { width, height };\r\n                }],\r\n            [Enums_1.Fields.Alive, (entity) => {\r\n                    const alive = this.packet.ReadI8() === 0x01;\r\n                    entity.alive = alive;\r\n                    if (alive) {\r\n                        this.client.canvas.phase = Enums_1.Phases.Arena;\r\n                        this.client.elements.homescreen.homescreen.style.display = \"none\";\r\n                        this.client.elements.arena.stats.style.display =\r\n                            this.client.elements.arena.utils.style.display =\r\n                                this.client.canvas.mapCanvas.style.display = \"block\";\r\n                    }\r\n                }],\r\n            [Enums_1.Fields.Angle, (entity) => {\r\n                    const angle = this.packet.ReadFloat32();\r\n                    entity.angle.target = angle;\r\n                }],\r\n            [Enums_1.Fields.Health, () => {\r\n                    const health = this.packet.ReadI8();\r\n                    this.client.elements.update(\"health\", health);\r\n                }],\r\n            [Enums_1.Fields.Armor, () => {\r\n                    const armor = this.packet.ReadI8();\r\n                    this.client.elements.update(\"armor\", armor);\r\n                }],\r\n            [Enums_1.Fields.Energy, () => {\r\n                    const energy = this.packet.ReadI8();\r\n                    this.client.elements.update(\"energy\", energy);\r\n                }],\r\n        ]);\r\n        this.connection = connection;\r\n        this.client = connection.client;\r\n        this.player = this.client.player;\r\n    }\r\n    parse(packet) {\r\n        this.packet = packet;\r\n        this.packet.ReadI8(); // Header\r\n        const group = this.nextGroup();\r\n        if (group === 0x00) {\r\n            const fieldLength = this.packet.ReadI8();\r\n            this.nextFields(fieldLength);\r\n        }\r\n        const surroundings = group !== 0x00 ? group : this.packet.ReadI8();\r\n        // split buffer from current position\r\n        if (surroundings === 0x01) {\r\n            const entityLength = this.packet.ReadI8();\r\n            this.nextEntities(entityLength);\r\n        }\r\n        this.player.surroundings = this.player.surroundings.filter(entity => entity.updated);\r\n        this.player.surroundings.forEach(entity => entity.updated = false);\r\n    }\r\n    nextGroup() {\r\n        return this.packet.ReadI8();\r\n    }\r\n    nextFields(length, entity) {\r\n        for (; length--;) {\r\n            const field = this.packet.ReadI8();\r\n            const executor = this.fieldMap.get(field);\r\n            if (!executor)\r\n                Logger_1.default.err(`Unknown field ${field}!`);\r\n            else\r\n                executor(entity || this.player);\r\n        }\r\n    }\r\n    nextEntities(length) {\r\n        for (; length--;) {\r\n            const entity = this.packet.ReadI8();\r\n            const fieldLength = this.packet.ReadI8() - 1;\r\n            const IDField = this.packet.ReadI8();\r\n            const ID = this.packet.ReadI8();\r\n            let _entity = this.player.surroundings.find(entity => entity.id === ID);\r\n            if (!_entity) {\r\n                switch (entity) {\r\n                    case Enums_1.Entities.Box: _entity = new Box_1.default();\r\n                }\r\n                _entity.id = ID;\r\n                this.player.surroundings.push(_entity);\r\n            }\r\n            _entity.updated = true;\r\n            this.nextFields(fieldLength, _entity);\r\n        }\r\n    }\r\n}\r\nexports[\"default\"] = UpdateParser;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Connection/Helpers/UpdateParser.ts?");

/***/ }),

/***/ "./views/client/Connection/MessageHandler.ts":
/*!***************************************************!*\
  !*** ./views/client/Connection/MessageHandler.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst SwiftStream_1 = __importDefault(__webpack_require__(/*! ./SwiftStream */ \"./views/client/Connection/SwiftStream.ts\"));\r\nconst UpdateParser_1 = __importDefault(__webpack_require__(/*! ./Helpers/UpdateParser */ \"./views/client/Connection/Helpers/UpdateParser.ts\"));\r\n/** A handler for all incoming messages. */\r\nclass MessageHandler {\r\n    constructor(connection) {\r\n        /** The update parser. */\r\n        this.UpdateParser = null;\r\n        this.connection = connection;\r\n    }\r\n    // Woah, that's a big packet!\r\n    Update() {\r\n        const SS = new SwiftStream_1.default();\r\n        SS.Set(this.connection.SwiftStream.buffer);\r\n        if (!this.UpdateParser)\r\n            this.UpdateParser = new UpdateParser_1.default(this.connection);\r\n        this.UpdateParser.parse(SS);\r\n    }\r\n}\r\nexports[\"default\"] = MessageHandler;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Connection/MessageHandler.ts?");

/***/ }),

/***/ "./views/client/Connection/SwiftStream.ts":
/*!************************************************!*\
  !*** ./views/client/Connection/SwiftStream.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n/** BUFFERS: Used to convert between different byte lengths. */\r\nconst conversion = new ArrayBuffer(4);\r\nconst u8 = new Uint8Array(conversion);\r\nconst f32 = new Float32Array(conversion);\r\n/** SwiftStream, an efficient binary protocol manager written by Altanis. */\r\nclass SwiftStream {\r\n    constructor() {\r\n        /** The buffer SwiftStream is using. */\r\n        this.buffer = new Uint8Array(4096);\r\n        /** The position at which the buffer is being read. */\r\n        this.at = 0;\r\n        /** UTF8 Decoder. */\r\n        this.TextDecoder = new TextDecoder();\r\n        /** UTF8 Encoder. */\r\n        this.TextEncoder = new TextEncoder();\r\n    }\r\n    Set(buffer) {\r\n        this.buffer = buffer;\r\n        this.at = 0;\r\n    }\r\n    Clear() {\r\n        this.buffer = new Uint8Array(4096);\r\n        this.at = 0;\r\n    }\r\n    /** READER */\r\n    ReadI8() {\r\n        return this.buffer[this.at++];\r\n    }\r\n    ReadFloat32() {\r\n        u8.set(this.buffer.slice(this.at, this.at += 4));\r\n        return f32[0];\r\n    }\r\n    ReadUTF8String() {\r\n        const start = this.at;\r\n        while (this.buffer[this.at++])\r\n            ;\r\n        return this.TextDecoder.decode(this.buffer.slice(start, this.at - 1));\r\n    }\r\n    /** WRITER */\r\n    WriteI8(value) {\r\n        this.buffer[this.at++] = value;\r\n        return this;\r\n    }\r\n    WriteFloat32(value) {\r\n        f32[0] = value;\r\n        this.buffer.set(u8, this.at);\r\n        this.at += 4;\r\n        return this;\r\n    }\r\n    WriteCString(value) {\r\n        this.buffer.set(this.TextEncoder.encode(value), this.at);\r\n        this.at += value.length;\r\n        this.buffer[this.at++] = 0;\r\n        return this;\r\n    }\r\n    Write() {\r\n        const result = this.buffer.subarray(0, this.at);\r\n        this.Clear();\r\n        return result;\r\n    }\r\n}\r\nexports[\"default\"] = SwiftStream;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Connection/SwiftStream.ts?");

/***/ }),

/***/ "./views/client/Const/Definitions.ts":
/*!*******************************************!*\
  !*** ./views/client/Const/Definitions.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Weapons = exports.Abilities = exports.Characters = void 0;\r\n/** Characters and all their necessary clientside data. */\r\nconst Characters = [\r\n    /** Knight */\r\n    {\r\n        name: \"Knight\",\r\n        stats: {\r\n            health: 7,\r\n            armor: 6,\r\n            energy: 250\r\n        },\r\n        abilities: [0, 1],\r\n        src: \"Knight.gif\",\r\n        speed: 5,\r\n    },\r\n    {\r\n        name: \"Priest\",\r\n        stats: {\r\n            health: 7,\r\n            armor: 6,\r\n            energy: 300\r\n        },\r\n        abilities: [1],\r\n        src: \"Priest.gif\",\r\n        speed: 5,\r\n    }\r\n];\r\nexports.Characters = Characters;\r\n/** Abilities, a specific property of characters. */\r\nconst Abilities = [\r\n    /** Dual Wield */\r\n    {\r\n        name: \"Dual Wield\",\r\n        description: \"Attack with double the power.\",\r\n        src: \"dual_wield.png\",\r\n    },\r\n    /** Charge */\r\n    {\r\n        name: \"Charge\",\r\n        description: \"Bash into a foe with your shield.\",\r\n        src: \"charge.png\",\r\n    }\r\n];\r\nexports.Abilities = Abilities;\r\n/** Weapons, objects used to attack. */\r\nconst Weapons = [\r\n    /** Rusty Blade */\r\n    {\r\n        name: \"Rusty Blade\",\r\n        type: \"melee\",\r\n        rarity: \"common\",\r\n        damage: 10,\r\n        range: Math.PI / 4,\r\n        speed: 30,\r\n        src: \"rusty_blade\",\r\n        offsetX: 0,\r\n        offsetY: 0\r\n    }\r\n];\r\nexports.Weapons = Weapons;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Const/Definitions.ts?");

/***/ }),

/***/ "./views/client/Const/Enums.ts":
/*!*************************************!*\
  !*** ./views/client/Const/Enums.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Movement = exports.Entities = exports.Fields = exports.ServerBound = exports.ClientBound = exports.Phases = exports.CloseEvents = void 0;\r\n/** Representation of possible reasons the connection was closed. */\r\nexports.CloseEvents = {\r\n    3000: \"The server has detected multiple connections by you. Please terminate any existing connections.\",\r\n    3001: \"The server is full.\",\r\n    3002: \"The server has detected a malformed request made by you. Please refresh.\",\r\n    3003: \"The server has detected that you are a banned player.\",\r\n    3006: \"An unknown error has occurred. Please refresh.\"\r\n};\r\n/** Representation of the phase canvas is rendering. */\r\nvar Phases;\r\n(function (Phases) {\r\n    Phases[Phases[\"Homescreen\"] = 0] = \"Homescreen\";\r\n    Phases[Phases[\"Arena\"] = 1] = \"Arena\";\r\n})(Phases = exports.Phases || (exports.Phases = {}));\r\n;\r\nvar ClientBound;\r\n(function (ClientBound) {\r\n    /** Tells the client of it's surroundings. */\r\n    ClientBound[ClientBound[\"Update\"] = 0] = \"Update\";\r\n})(ClientBound = exports.ClientBound || (exports.ClientBound = {}));\r\n;\r\nvar ServerBound;\r\n(function (ServerBound) {\r\n    /** Client tells the server they want to spawn. [string(name), i8(characterIdx), i8(abilityIdx)] */\r\n    ServerBound[ServerBound[\"Spawn\"] = 0] = \"Spawn\";\r\n    /** Client tells the server they want to move. [i8(Movement)] */\r\n    ServerBound[ServerBound[\"Movement\"] = 1] = \"Movement\";\r\n    /** The angle the player is facing, in radians. [f32(angle)] */\r\n    ServerBound[ServerBound[\"Angle\"] = 2] = \"Angle\";\r\n    /** Client tells the server they want to attack. */\r\n    ServerBound[ServerBound[\"Attack\"] = 3] = \"Attack\";\r\n    /** Client cheats (when given developer code). */\r\n    ServerBound[ServerBound[\"Cheats\"] = 255] = \"Cheats\";\r\n})(ServerBound = exports.ServerBound || (exports.ServerBound = {}));\r\n;\r\n/** Fields of the Update packet. */\r\nvar Fields;\r\n(function (Fields) {\r\n    /** The ID of the entity. */\r\n    Fields[Fields[\"ID\"] = 0] = \"ID\";\r\n    /** The position of the entity. */\r\n    Fields[Fields[\"Position\"] = 1] = \"Position\";\r\n    /** If the entity is attacking. */\r\n    Fields[Fields[\"Attacking\"] = 2] = \"Attacking\";\r\n    /** The weapon(s) of the player. */\r\n    Fields[Fields[\"Weapons\"] = 3] = \"Weapons\";\r\n    /** The resolution (FoV) of the entity. */\r\n    Fields[Fields[\"FOV\"] = 4] = \"FOV\";\r\n    /** The dimensions of the entity. */\r\n    Fields[Fields[\"Dimensions\"] = 5] = \"Dimensions\";\r\n    /** Whether or not the entity is alive. */\r\n    Fields[Fields[\"Alive\"] = 6] = \"Alive\";\r\n    /** The angle of the entity. */\r\n    Fields[Fields[\"Angle\"] = 7] = \"Angle\";\r\n    /** The health of the entity. */\r\n    Fields[Fields[\"Health\"] = 8] = \"Health\";\r\n    /** The armor of the entity. */\r\n    Fields[Fields[\"Armor\"] = 9] = \"Armor\";\r\n    /** The energy of the entity. */\r\n    Fields[Fields[\"Energy\"] = 10] = \"Energy\";\r\n})(Fields = exports.Fields || (exports.Fields = {}));\r\n;\r\n/** Object types. */\r\nvar Entities;\r\n(function (Entities) {\r\n    Entities[Entities[\"Player\"] = 0] = \"Player\";\r\n    Entities[Entities[\"Box\"] = 1] = \"Box\";\r\n})(Entities = exports.Entities || (exports.Entities = {}));\r\n/** Movement codes. */\r\nvar Movement;\r\n(function (Movement) {\r\n    Movement[Movement[\"Up\"] = 1] = \"Up\";\r\n    Movement[Movement[\"Right\"] = 2] = \"Right\";\r\n    Movement[Movement[\"Down\"] = 3] = \"Down\";\r\n    Movement[Movement[\"Left\"] = 4] = \"Left\";\r\n})(Movement = exports.Movement || (exports.Movement = {}));\r\n;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Const/Enums.ts?");

/***/ }),

/***/ "./views/client/Entity/Box.ts":
/*!************************************!*\
  !*** ./views/client/Entity/Box.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst _Entity_1 = __importDefault(__webpack_require__(/*! ./_Entity */ \"./views/client/Entity/_Entity.ts\"));\r\nclass Box extends _Entity_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** The dimensions of the box. */\r\n        this.dimensions = { width: 300, height: 300 };\r\n        this.health = 100;\r\n        this.maxHealth = 100;\r\n    }\r\n    render(ctx, frame) {\r\n        this.ticks++;\r\n        const pos = this.lerpPosition(frame);\r\n        const { width, height } = this.dimensions;\r\n        ctx.fillStyle = \"red\";\r\n        ctx.fillRect(pos.x, pos.y, width, height);\r\n    }\r\n}\r\nexports[\"default\"] = Box;\r\n;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Entity/Box.ts?");

/***/ }),

/***/ "./views/client/Entity/Player.ts":
/*!***************************************!*\
  !*** ./views/client/Entity/Player.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Definitions_1 = __webpack_require__(/*! ../Const/Definitions */ \"./views/client/Const/Definitions.ts\");\r\nconst Config_1 = __webpack_require__(/*! ../Utils/Config */ \"./views/client/Utils/Config.ts\");\r\nconst _Entity_1 = __importDefault(__webpack_require__(/*! ./_Entity */ \"./views/client/Entity/_Entity.ts\"));\r\n/** A representation of a Player entity. */\r\nclass Player extends _Entity_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** The character index of the player. */\r\n        this.character = 0;\r\n        /** The ability index of the player. */\r\n        this.ability = 0;\r\n        /** The weapon the player is holding. */\r\n        this.weapon = 0;\r\n        /** If the player is alive. */\r\n        this.alive = false;\r\n        /** The dimensions of the player. */\r\n        this.dimensions = { width: 300, height: 300 };\r\n        /** Attack information of the player. */\r\n        this.attack = {\r\n            /** Whether or not the player is attacking. */\r\n            attacking: {\r\n                /** The client-side state. */\r\n                client: false,\r\n                /** The server-side state. */\r\n                server: false,\r\n                /** Whether or not to change state. */\r\n                change: false\r\n            },\r\n            /** The direction of angle movement. */\r\n            direction: 1,\r\n            /** The mouse angle when attacking. */\r\n            mouse: 0,\r\n            /** The lerp factor at which the mouse should go in between [posRange, negRange]. */\r\n            lerpFactor: 0,\r\n            /** The amount of times the direction has been reversed. */\r\n            cycles: 0\r\n        };\r\n        /** The field of vision of the player. */\r\n        this.fov = 0.9;\r\n        /** The entities surrounding the player. */\r\n        this.surroundings = [];\r\n        /** The health of the player. */\r\n        this.health = this.maxHealth;\r\n        /** The armor of the player. */\r\n        this.armor = this.maxArmor;\r\n        /** The energy of the player. */\r\n        this.energy = this.maxEnergy;\r\n        /** Private rendering utils for bars. */\r\n        this.healthWidth = this.health;\r\n        this.armorWidth = this.armor;\r\n        this.energyWidth = this.energy;\r\n        /** Death animation information for the character. */\r\n        this.deathAnim = {\r\n            phase: 0,\r\n            size: this.dimensions.height,\r\n            targetSize: this.dimensions.height * 1.5,\r\n            transparency: 0,\r\n            targetTransparency: 1,\r\n            ticks: 0,\r\n            targetTicks: 30\r\n        };\r\n    }\r\n    /** The maximum health of the player. */\r\n    get maxHealth() {\r\n        return Definitions_1.Characters[this.character].stats.health;\r\n    }\r\n    ;\r\n    /** The maximum armor of the player. */\r\n    get maxArmor() {\r\n        return Definitions_1.Characters[this.character].stats.armor;\r\n    }\r\n    ;\r\n    /** The maximum energy of the player. */\r\n    get maxEnergy() {\r\n        return Definitions_1.Characters[this.character].stats.energy;\r\n    }\r\n    ;\r\n    /** Renders the player onto the canvas. */\r\n    render(manager, ctx, position, angle) {\r\n        this.ticks++;\r\n        if (!this.alive && this.deathAnim.phase === 0)\r\n            this.destroy(manager, position);\r\n        else if (this.deathAnim.phase === 1)\r\n            this.destroy(manager, position);\r\n        if (!this.alive)\r\n            return;\r\n        const c = Definitions_1.Characters[this.character];\r\n        const w = Definitions_1.Weapons[this.weapon];\r\n        if (angle > Math.PI)\r\n            angle = Math.PI - 0.01;\r\n        else if (angle < -Math.PI)\r\n            angle = -Math.PI + 0.01;\r\n        const scaleX = (angle > Math.PI / 2 && angle < Math.PI) || (angle < -Math.PI / 2 && angle > -Math.PI) ? -1 : 1; // TODO(Altanis): Fix for attacking.\r\n        ctx.translate(position.x, position.y);\r\n        this.renderBars(ctx, manager);\r\n        ctx.scale(scaleX, 1);\r\n        /** Render character. */\r\n        const character = manager.ImageManager.get(`img/characters/frames/${c.name}/${c.name}`, true);\r\n        if (!character)\r\n            return;\r\n        ctx.drawImage(character, -150, -150, this.dimensions.width, this.dimensions.height);\r\n        /** Render weapon. */\r\n        const weapon = manager.ImageManager.get(`img/weapons/${w.src}`);\r\n        if (!weapon)\r\n            return;\r\n        if (scaleX === -1) {\r\n            if (angle > -Math.PI / 2 && angle < Math.PI) {\r\n                angle = Math.PI - angle;\r\n            }\r\n            else if (angle < -Math.PI / 2 && angle > -Math.PI) {\r\n                angle = Math.abs(angle + (Math.PI / 2)) - (Math.PI / 2);\r\n            }\r\n        }\r\n        ctx.rotate(angle);\r\n        ctx.drawImage(weapon, w.offsetX, w.offsetY, 200, 40);\r\n        // TODO(Altanis): Create a blue tracer to illustrate the path of the sword.\r\n        ctx.restore();\r\n        /** Render position on the minimap. */\r\n        manager.mapCtx.fillStyle = \"#FFFFFF\";\r\n        const minimapX = position.x * manager.mapCanvas.width / Config_1.ARENA_SIZE;\r\n        const minimapY = position.y * manager.mapCanvas.height / Config_1.ARENA_SIZE;\r\n        manager.drawCircle(minimapX, minimapY, 2, manager.mapCtx);\r\n    }\r\n    destroy(manager, position) {\r\n        this.deathAnim.phase = 1;\r\n        const size = this.deathAnim.size + (((this.deathAnim.targetSize - this.deathAnim.size) / this.deathAnim.targetTicks) * this.deathAnim.ticks);\r\n        const transparency = ((this.deathAnim.targetTransparency - this.deathAnim.transparency) / this.deathAnim.targetTicks) * this.deathAnim.ticks;\r\n        console.log(size, 1 - transparency);\r\n        const c = Definitions_1.Characters[this.character];\r\n        const character = manager.ImageManager.get(`img/characters/frames/${c.name}/${c.name}`, true);\r\n        if (!character)\r\n            return;\r\n        /** Set transparency of drawImage. */\r\n        manager.ctx.save();\r\n        manager.ctx.translate(position.x, position.y);\r\n        manager.ctx.globalAlpha = 1 - transparency;\r\n        manager.ctx.drawImage(character, -(size / 2), -(size / 2), size, size);\r\n        manager.ctx.restore();\r\n        if (++this.deathAnim.ticks >= this.deathAnim.targetTicks)\r\n            this.deathAnim.phase = 2;\r\n    }\r\n    renderBars(ctx, manager) {\r\n        /** Render health bar. */\r\n        if (this.health !== this.healthWidth) {\r\n            this.healthWidth += this.healthWidth < this.health ? 0.2 : -0.2;\r\n            // TODO(Altanis): Ensure they collide at some point.\r\n            if (this.healthWidth < this.health ?\r\n                this.healthWidth > this.health :\r\n                this.healthWidth < this.health)\r\n                this.healthWidth = this.health;\r\n        }\r\n        ctx.fillStyle = \"#3d3f43\";\r\n        manager.roundRect(-85, 200, 200, 20, 8);\r\n        ctx.fillStyle = \"#FD3B3B\"; // opponent is #cc5152\r\n        manager.roundRect(-85, 200, 200 * (this.healthWidth / this.maxHealth), 20, 7);\r\n        /** Render armor bar. */\r\n        if (this.armor !== this.armorWidth) {\r\n            this.armorWidth += this.armorWidth < this.armor ? 0.2 : -0.2;\r\n            // TODO(Altanis): Ensure they collide at some point.\r\n            if (this.armorWidth < this.armor ?\r\n                this.armorWidth > this.armor :\r\n                this.armorWidth < this.armor)\r\n                this.armorWidth = this.armor;\r\n        }\r\n        ctx.fillStyle = \"#3d3f43\";\r\n        manager.roundRect(-85, 225, 200, 20, 8);\r\n        ctx.fillStyle = \"#A8D657\"; // opponent is #cc5152\r\n        manager.roundRect(-85, 225, 200 * (this.armorWidth / this.maxArmor), 20, 7);\r\n        /** Render energy bar. */\r\n        if (this.energy !== this.energyWidth) {\r\n            this.energyWidth += this.energyWidth < this.energy ? 0.2 : -0.2;\r\n            // TODO(Altanis): Ensure they collide at some point.\r\n            if (this.energyWidth < this.energy ?\r\n                this.energyWidth > this.energy :\r\n                this.energyWidth < this.energy)\r\n                this.energyWidth = this.energy;\r\n        }\r\n        ctx.fillStyle = \"#3d3f43\";\r\n        manager.roundRect(-85, 250, 200, 20, 8);\r\n        ctx.fillStyle = \"#7300FF\"; // opponent is #cc5152\r\n        manager.roundRect(-85, 250, 200 * (this.energyWidth / this.maxEnergy), 20, 7);\r\n        /*ctx.fillStyle = \"#FFFFFF\";\r\n        ctx.font = \"12px Orbitron\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.fillText(`${this.health}/${this.maxHealth}`, 0, 215);\r\n        ctx.fillText(`${this.armor}/${this.maxArmor}`, 0, 240);\r\n        ctx.fillText(`${this.energy}/${this.maxEnergy}`, 0, 265);*/\r\n    }\r\n}\r\nexports[\"default\"] = Player;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Entity/Player.ts?");

/***/ }),

/***/ "./views/client/Entity/_Entity.ts":
/*!****************************************!*\
  !*** ./views/client/Entity/_Entity.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Functions_1 = __webpack_require__(/*! ../Utils/Functions */ \"./views/client/Utils/Functions.ts\");\r\nconst Config_1 = __webpack_require__(/*! ../Utils/Config */ \"./views/client/Utils/Config.ts\");\r\nclass Entity {\r\n    constructor() {\r\n        /** The ID of the entity. */\r\n        this.id = -1;\r\n        /** The position of the entity. */\r\n        this.position = {\r\n            current: { x: 0, y: 0 },\r\n            target: { x: 0, y: 0 },\r\n            /** The velocity of the player. */\r\n            velocity: {\r\n                current: { x: 0, y: 0 },\r\n                target: { x: 0, y: 0 }\r\n            }\r\n        };\r\n        /** The angle of the entity. */\r\n        this.angle = {\r\n            current: 0,\r\n            target: 0,\r\n            /** Interpolation factor. */\r\n            factor: 0\r\n        };\r\n        /** Disable lerp for the entity (initial frame when seen). */\r\n        this.noLerp = true;\r\n        /** If the entity was updated last tick. */\r\n        this.updated = false;\r\n        /** The dimensions of the player. */\r\n        this.dimensions = { width: 0, height: 0 };\r\n        /** Ticks since the entity was created. */\r\n        this.ticks = 0;\r\n    }\r\n    lerpPosition(deltaTick) {\r\n        if (this.ticks <= 2)\r\n            return this.position.current = this.position.target;\r\n        this.position.current.x = (0, Functions_1.lerp)(this.position.current.x, this.position.target.x, 0.1 * deltaTick);\r\n        this.position.current.y = (0, Functions_1.lerp)(this.position.current.y, this.position.target.y, 0.1 * deltaTick);\r\n        this.position.current.x = (0, Functions_1.constrain)(0, this.position.current.x, Config_1.ARENA_SIZE);\r\n        this.position.current.y = (0, Functions_1.constrain)(0, this.position.current.y, Config_1.ARENA_SIZE);\r\n        /** @ts-ignore */\r\n        this.position.velocity.current.x = (0, Functions_1.lerp)(this.position.velocity.current.x, this.position.velocity.target.x, 0.01 * deltaTick);\r\n        /** @ts-ignore */\r\n        this.position.velocity.current.y = (0, Functions_1.lerp)(this.position.velocity.current.y, this.position.velocity.target.y, 0.01 * deltaTick);\r\n        return this.position.current;\r\n    }\r\n    render(...args) { }\r\n    ;\r\n    destroy(manager, ...args) { }\r\n    ;\r\n}\r\nexports[\"default\"] = Entity;\r\n;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Entity/_Entity.ts?");

/***/ }),

/***/ "./views/client/Index.ts":
/*!*******************************!*\
  !*** ./views/client/Index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Client_1 = __importDefault(__webpack_require__(/*! ./Client */ \"./views/client/Client.ts\"));\r\nconst Enums_1 = __webpack_require__(/*! ./Const/Enums */ \"./views/client/Const/Enums.ts\");\r\nconst client = new Client_1.default();\r\nconst KEYDOWN_MAP = new Map([\r\n    /** Movement keys. */\r\n    [38, 1],\r\n    [87, 1],\r\n    [39, 2],\r\n    [68, 2],\r\n    [40, 3],\r\n    [83, 3],\r\n    [37, 4],\r\n    [65, 4],\r\n]);\r\nclient.elements.canvas.addEventListener('contextmenu', event => event.preventDefault());\r\ndocument.addEventListener(\"keydown\", function (event) {\r\n    switch (event.code) {\r\n        case \"Enter\": {\r\n            if ( /** activeElement === NameInput && */client.elements.homescreen.play.style.display === \"block\") {\r\n                client.elements.homescreen.play.click();\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    const key = KEYDOWN_MAP.get(event.which || event.keyCode);\r\n    if (key) {\r\n        client.elements.activeKeys.add(key);\r\n        switch (key) {\r\n            case Enums_1.Movement.Right:\r\n                client.player.position.velocity.target.x = 30;\r\n                break;\r\n            case Enums_1.Movement.Left:\r\n                client.player.position.velocity.target.x = -30;\r\n                break;\r\n            case Enums_1.Movement.Up:\r\n                client.player.position.velocity.target.y = -30;\r\n                break;\r\n            case Enums_1.Movement.Down:\r\n                client.player.position.velocity.target.y = 30;\r\n                break;\r\n        }\r\n        /*switch (key) {\r\n            case Movement.Right: client.player.position.velocity.target.x = Characters[client.player.character].speed; break;\r\n            case Movement.Left: client.player.position.velocity.target.x = -Characters[client.player.character].speed; break;\r\n            case Movement.Up: client.player.position.velocity.target.y = -Characters[client.player.character].speed; break;\r\n            case Movement.Down: client.player.position.velocity.target.y = Characters[client.player.character].speed; break;\r\n        }*/\r\n        /*if (client.player.position.velocity.x === 0 && client.player.position.velocity.y === 0) {\r\n            switch (key) {\r\n                case Movement.Up: client.player.position.velocity.y = -Characters[client.player.character].speed; break;\r\n                case Movement.Right: client.player.position.velocity.x = Characters[client.player.character].speed; break;\r\n                case Movement.Down: client.player.position.velocity.y = Characters[client.player.character].speed; break;\r\n                case Movement.Left: client.player.position.velocity.x = -Characters[client.player.character].speed; break;\r\n            }\r\n        }*/\r\n        event.preventDefault();\r\n    }\r\n});\r\ndocument.addEventListener(\"keyup\", function (event) {\r\n    const key = KEYDOWN_MAP.get(event.which || event.keyCode);\r\n    if (key) {\r\n        client.elements.activeKeys.delete(key);\r\n        switch (key) {\r\n            case Enums_1.Movement.Up:\r\n                client.player.position.velocity.target.y = 0;\r\n                break;\r\n            case Enums_1.Movement.Right:\r\n                client.player.position.velocity.target.x = 0;\r\n                break;\r\n            case Enums_1.Movement.Down:\r\n                client.player.position.velocity.target.y = 0;\r\n                break;\r\n            case Enums_1.Movement.Left:\r\n                client.player.position.velocity.target.x = 0;\r\n                break;\r\n        }\r\n        event.preventDefault();\r\n    }\r\n});\r\ndocument.addEventListener(\"mousemove\", function (event) {\r\n    client.elements.mouse = {\r\n        x: event.clientX,\r\n        y: event.clientY\r\n    };\r\n});\r\nclient.elements.canvas.addEventListener(\"mousedown\", function (event) {\r\n    if (client.canvas.phase === Enums_1.Phases.Arena)\r\n        client.player.attack.attacking.client = true;\r\n    event.preventDefault();\r\n});\r\nclient.elements.canvas.addEventListener(\"mouseup\", function (event) {\r\n    if (client.canvas.phase === Enums_1.Phases.Arena)\r\n        client.player.attack.attacking.client = false;\r\n    event.preventDefault();\r\n});\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Index.ts?");

/***/ }),

/***/ "./views/client/Rendering/CanvasManager.ts":
/*!*************************************************!*\
  !*** ./views/client/Rendering/CanvasManager.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Enums_1 = __webpack_require__(/*! ../Const/Enums */ \"./views/client/Const/Enums.ts\");\r\nconst Config_1 = __webpack_require__(/*! ../Utils/Config */ \"./views/client/Utils/Config.ts\");\r\nconst Functions_1 = __webpack_require__(/*! ../Utils/Functions */ \"./views/client/Utils/Functions.ts\");\r\nconst ImageManager_1 = __importDefault(__webpack_require__(/*! ./ImageManager */ \"./views/client/Rendering/ImageManager.ts\"));\r\n/** Constant for 360 degrees in radians. */\r\nconst TAU = Math.PI * 2;\r\n/** Psuedorandom number in between two ranges. */\r\n/** The canvas where nearly all visual representation is drawn. */\r\nclass CanvasManager {\r\n    constructor(client) {\r\n        /** CANVAS */\r\n        /** @ts-ignore */\r\n        this.canvas = document.getElementById(\"canvas\");\r\n        /** The context to draw on. */\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        /** MAP CANVAS */\r\n        /** @ts-ignore */\r\n        this.mapCanvas = document.getElementById(\"mapDisplay\");\r\n        /** The context to draw on for the minimap. */\r\n        this.mapCtx = this.mapCanvas.getContext(\"2d\");\r\n        /** The phase in which rendering is occuring. */\r\n        this.phase = Enums_1.Phases.Homescreen;\r\n        /** The difference in between two frame renders. */\r\n        this.delta = 0;\r\n        /** The variable which keeps track of the last update. */\r\n        this.lastUpdate = 0;\r\n        /** The object which tracks FPS. */\r\n        this.FPS = {\r\n            fps: [0]\r\n        };\r\n        /** Manager for images. */\r\n        this.ImageManager = new ImageManager_1.default();\r\n        /** The stars on the homescreen. */\r\n        this.stars = {\r\n            count: 200,\r\n            stars: [],\r\n            radiusIncrement: 0.1\r\n        };\r\n        this.client = client;\r\n    }\r\n    render() {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.mapCtx.clearRect(0, 0, this.mapCanvas.width, this.mapCanvas.height);\r\n        this.delta = Date.now() - this.lastUpdate;\r\n        this.lastUpdate = Date.now();\r\n        switch (this.phase) {\r\n            case Enums_1.Phases.Homescreen:\r\n                this.Homescreen();\r\n                break;\r\n            case Enums_1.Phases.Arena:\r\n                this.Arena(this.delta);\r\n                break;\r\n        }\r\n    }\r\n    /** UTILITIES */\r\n    roundRect(x, y, w, h, r, ctx = this.ctx) {\r\n        if (w < 2 * r)\r\n            r = w / 2;\r\n        if (h < 2 * r)\r\n            r = h / 2;\r\n        /** @ts-ignore */\r\n        r = r - (r < 0) * r;\r\n        const xr = x + r, xw = x + w, yh = y + h;\r\n        ctx.beginPath();\r\n        ctx.moveTo(xr, y);\r\n        ctx.arcTo(xw, y, xw, yh, r);\r\n        ctx.arcTo(xw, yh, x, yh, r);\r\n        ctx.arcTo(x, yh, x, y, r);\r\n        ctx.arcTo(x, y, xw, y, r);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n    }\r\n    drawCircle(x, y, r, ctx = this.ctx) {\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, r, 0, TAU);\r\n        ctx.fill();\r\n    }\r\n    /** Renders the homescreen background (with pulsating stars). */\r\n    Homescreen() {\r\n        this.ctx.fillStyle = \"#000000\";\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.fillStyle = \"#FFFFFF\";\r\n        for (let i = this.stars.count - this.stars.stars.length; --i;) {\r\n            this.stars.stars.push({\r\n                x: (0, Functions_1.randomRange)(0, this.canvas.width),\r\n                y: (0, Functions_1.randomRange)(0, this.canvas.width),\r\n                radius: (0, Functions_1.randomRange)(0.1, 1.5),\r\n            });\r\n        }\r\n        for (let i = this.stars.stars.length; i--;) {\r\n            const star = this.stars.stars[i];\r\n            this.drawCircle(star.x, star.y, star.radius);\r\n            star.radius += this.stars.radiusIncrement;\r\n            if (star.radius >= 3)\r\n                this.stars.stars.splice(i, 1);\r\n        }\r\n    }\r\n    /** Renders the actual arena when spawned in. */\r\n    Arena(delta) {\r\n        /** Update FPS. */\r\n        if (this.FPS.fps.length > 30)\r\n            this.FPS.fps.shift();\r\n        this.FPS.fps.push(delta);\r\n        const deltaAverage = (this.FPS.fps.reduce((a, b) => a + b) / this.FPS.fps.length);\r\n        this.client.elements.arena.fps.innerText = (1000 / deltaAverage).toFixed(1) + '  FPS';\r\n        // RENDER OUTBOUNDS:\r\n        this.ctx.fillStyle = \"rgba(12, 50, 54, 1)\";\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.save();\r\n        const deltaTick = (0, Functions_1.constrain)(0, deltaAverage / 16.66, 1);\r\n        const pos = this.client.player.lerpPosition(deltaTick);\r\n        // TODO(Altanis): Fix how angle is lerped.\r\n        const angle = this.client.player.angle.current = (0, Functions_1.lerpAngle)(this.client.player.angle.current, this.client.player.angle.target, 0.35 * deltaTick);\r\n        let { x: cameraX, y: cameraY } = pos;\r\n        /** Set up player camera. */\r\n        const factor = Math.min(this.canvas.width / 1080, this.canvas.height / 1920);\r\n        this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2); // Set <0, 0> to center.\r\n        this.ctx.scale(factor * this.client.player.fov, factor * this.client.player.fov);\r\n        this.ctx.translate(-cameraX + this.client.player.position.velocity.current.x, -cameraY + this.client.player.position.velocity.current.y);\r\n        // RENDER INBOUNDS:\r\n        this.ctx.strokeStyle = \"#2F8999\";\r\n        this.ctx.lineWidth = 10;\r\n        this.ctx.fillStyle = \"rgb(5,28,31)\";\r\n        this.ctx.strokeRect(0, 0, Config_1.ARENA_SIZE, Config_1.ARENA_SIZE);\r\n        this.ctx.fillRect(0, 0, Config_1.ARENA_SIZE, Config_1.ARENA_SIZE);\r\n        // RENDER GRID:\r\n        this.ctx.strokeStyle = \"#334f52\";\r\n        this.ctx.lineWidth = 1;\r\n        for (let x = 0; x < Config_1.ARENA_SIZE; x += Config_1.GRID_SIZE) {\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(x, 0);\r\n            this.ctx.lineTo(x, Config_1.ARENA_SIZE);\r\n            this.ctx.stroke();\r\n        }\r\n        for (let y = 0; y < Config_1.ARENA_SIZE; y += Config_1.GRID_SIZE) {\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(0, y);\r\n            this.ctx.lineTo(Config_1.ARENA_SIZE, y);\r\n            this.ctx.stroke();\r\n        }\r\n        for (const entity of this.client.player.surroundings)\r\n            entity.render(this.ctx, deltaTick);\r\n        this.client.player.render(this, this.ctx, pos, angle);\r\n        this.ctx.restore();\r\n    }\r\n}\r\nexports[\"default\"] = CanvasManager;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Rendering/CanvasManager.ts?");

/***/ }),

/***/ "./views/client/Rendering/ElementManager.ts":
/*!**************************************************!*\
  !*** ./views/client/Rendering/ElementManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Definitions_1 = __webpack_require__(/*! ../Const/Definitions */ \"./views/client/Const/Definitions.ts\");\r\nconst Enums_1 = __webpack_require__(/*! ../Const/Enums */ \"./views/client/Const/Enums.ts\");\r\nconst Functions_1 = __webpack_require__(/*! ../Utils/Functions */ \"./views/client/Utils/Functions.ts\");\r\n/** Manages DOM elements. */\r\nclass ElementManager {\r\n    constructor(client) {\r\n        /** Interactive elements on the homescreen. */\r\n        this.homescreen = {\r\n            /** The div which contains all elements of the homescreen. */\r\n            homescreen: document.getElementById(\"homescreen\"),\r\n            /** The button which spawns the player. */\r\n            play: document.getElementById(\"play\"),\r\n            /** The input where the name is held. */\r\n            // none yet\r\n            /** The div which holds all 3 gamemode buttons. */\r\n            gamemodes: document.getElementById(\"gamemodes\"),\r\n            /** The button to trigger the settings modal. */\r\n            settings: document.getElementById(\"settings\"),\r\n            /** The screen which displays when the client has disconnected. */\r\n            disconnect: document.getElementById(\"disconnect\"),\r\n            /** The div with the character selector. */\r\n            characterSelector: {\r\n                /** The left arrow for the character. */\r\n                arrowLeft: document.getElementById(\"arrow-left\"),\r\n                /** The right arrow for the character. */\r\n                arrowRight: document.getElementById(\"arrow-right\"),\r\n                /** The name of the character. */\r\n                characterName: document.getElementById(\"character-name\"),\r\n                /** The sprite of the character. */\r\n                characterSprite: document.getElementById(\"character-sprite\"),\r\n                /** The name of the ability. */\r\n                abilityName: document.getElementById(\"ability-name\"),\r\n                /** The description of the ability. */\r\n                abilityDesc: document.getElementById(\"ability-desc\"),\r\n                /** The selector icons of the abilities. */\r\n                abilitySelector: document.getElementById(\"ability\")\r\n            }\r\n        };\r\n        /** Toggleable settings. */\r\n        this.settings = {\r\n            /** The div which contains toggleable settings. */\r\n            settings: document.getElementById(\"settingsModal\"),\r\n        };\r\n        /** Elements which display while playing. */\r\n        this.arena = {\r\n            /** The div containing all of these elements. */\r\n            game: document.getElementById(\"game\"),\r\n            /** The div which contains every stat of the player. */\r\n            stats: document.getElementById(\"stats\"),\r\n            /** The health bar in the stats div. */\r\n            health: document.getElementById(\"health\"),\r\n            /** The armor bar in the stats div. */\r\n            armor: document.getElementById(\"armor\"),\r\n            /** The energy bar in the stats div. */\r\n            energy: document.getElementById(\"energy\"),\r\n            /** The utils of the player, such as FPS/MS/Minimap. */\r\n            utils: document.getElementById(\"utils\"),\r\n            /** The name of the game. */\r\n            gameName: document.getElementById(\"gameName\"),\r\n            /** The FPS of the client. */\r\n            fps: document.getElementById(\"fps\"),\r\n            /** The ping of the client. */\r\n            ping: document.getElementById(\"ping\"),\r\n        };\r\n        /** Elements which play when the player disconnects from the game. */\r\n        this.disconnect = {\r\n            /** The div which contains the disconnect message. */\r\n            disconnect: document.getElementById(\"disconnect\"),\r\n            /** The message displayed when disconnecting. */\r\n            disconnectMessage: document.getElementById(\"disconnect-message\")\r\n        };\r\n        /** The canvas to draw on. */\r\n        /** @ts-ignore */\r\n        this.canvas = document.getElementById(\"canvas\");\r\n        /** The keys currently being pressed. */\r\n        this.activeKeys = new Set();\r\n        /** The mouse coordinates of the client. */\r\n        this.mouse = { x: 0, y: 0 };\r\n        this.client = client;\r\n        this.setup();\r\n        this.loop();\r\n    }\r\n    setup() {\r\n        /** Add resize handlers for the canvas. */\r\n        window.addEventListener(\"resize\", () => {\r\n            this.canvas.height = window.innerHeight * window.devicePixelRatio;\r\n            this.canvas.width = window.innerWidth * window.devicePixelRatio;\r\n        });\r\n        window.dispatchEvent(new Event(\"resize\"));\r\n        /** Add stat texts. */\r\n        document.querySelectorAll(\".progress-bar\").forEach((p, i) => {\r\n            let name = \"\";\r\n            switch (i) {\r\n                case 0:\r\n                    name = \"health\";\r\n                    break;\r\n                case 1:\r\n                    name = \"armor\";\r\n                    break;\r\n                case 2:\r\n                    name = \"energy\";\r\n                    break;\r\n            }\r\n            name += \"Text\";\r\n            /** @ts-ignore */\r\n            this.arena[name] = p.children[1];\r\n        });\r\n        /** Create pointers for abilities and characters. */\r\n        this.homescreen.characterSelector.arrowLeft.addEventListener(\"click\", () => {\r\n            this.client.player.character = (this.client.player.character - 1 + Definitions_1.Characters.length) % Definitions_1.Characters.length;\r\n            this.client.player.ability = Definitions_1.Characters[this.client.player.character].abilities[0];\r\n        });\r\n        this.homescreen.characterSelector.arrowRight.addEventListener(\"click\", () => {\r\n            this.client.player.character = (this.client.player.character + 1) % Definitions_1.Characters.length;\r\n            this.client.player.ability = Definitions_1.Characters[this.client.player.character].abilities[0];\r\n        });\r\n        /** Send play signal to server when Play is pressed. */\r\n        this.homescreen.play.addEventListener(\"click\", () => {\r\n            this.client.connection.send(Enums_1.ServerBound.Spawn, {\r\n                name: \"Altanis\"\r\n            });\r\n            const { health, armor, energy } = Definitions_1.Characters[this.client.player.character].stats;\r\n            /** @ts-ignore */\r\n            this.arena.healthText.innerText = `${health}/${health}`;\r\n            /** @ts-ignore */\r\n            this.arena.armorText.innerText = `${armor}/${armor}`;\r\n            /** @ts-ignore */\r\n            this.arena.energyText.innerText = `${energy}/${energy}`;\r\n        });\r\n    }\r\n    update(stat, target) {\r\n        const max = Definitions_1.Characters[this.client.player.character].stats[stat];\r\n        this.arena[stat + \"Text\"].innerText = `${target}/${max}`;\r\n        this.arena[stat].style.width = `${target / max * 100}%`;\r\n        this.client.player[stat] = target;\r\n    }\r\n    loop() {\r\n        var _a;\r\n        const player = this.client.player;\r\n        /** Update client's canvas. */\r\n        (_a = this.client.canvas) === null || _a === void 0 ? void 0 : _a.render();\r\n        /** Check if character has changed. */\r\n        let intuition = false;\r\n        const character = Definitions_1.Characters[player.character];\r\n        if (this.homescreen.characterSelector.characterName.innerText !== character.name) {\r\n            intuition = true;\r\n            this.homescreen.characterSelector.characterName.innerText = character.name;\r\n            /** @ts-ignore */\r\n            this.homescreen.characterSelector.characterSprite.src = `assets/img/characters/gifs/${character.src}`;\r\n        }\r\n        const playerAbility = Definitions_1.Abilities[player.ability];\r\n        if (this.homescreen.characterSelector.abilityName.innerHTML !== playerAbility.name || intuition) {\r\n            this.homescreen.characterSelector.abilityName.innerHTML = playerAbility.name;\r\n            this.homescreen.characterSelector.abilitySelector.innerHTML = \"\";\r\n            character.abilities.map(ability => Definitions_1.Abilities[ability]).forEach((ability, i) => {\r\n                const image = new Image(50, 50);\r\n                image.src = `assets/img/abilities/${ability.src}`;\r\n                image.classList.add(\"character-ability\");\r\n                if (ability.name === playerAbility.name) {\r\n                    this.homescreen.characterSelector.abilityDesc.innerText = ability.description;\r\n                    image.classList.add(\"selected\");\r\n                }\r\n                image.addEventListener(\"click\", () => {\r\n                    player.ability = character.abilities[i];\r\n                });\r\n                this.homescreen.characterSelector.abilitySelector.appendChild(image);\r\n            });\r\n        }\r\n        /** Recognize keypresses. */\r\n        if (this.activeKeys.size) {\r\n            this.client.connection.send(Enums_1.ServerBound.Movement, {\r\n                keys: this.activeKeys\r\n            });\r\n        }\r\n        /** Recognize mouse movements. */\r\n        if (this.mouse && player.alive && !player.attack.attacking.server) {\r\n            const old = player.angle.current;\r\n            const measure = Math.atan2(this.mouse.y - (this.canvas.height / 2), this.mouse.x - (this.canvas.width / 2));\r\n            if (old !== measure) {\r\n                this.client.connection.send(Enums_1.ServerBound.Angle, {\r\n                    measure\r\n                });\r\n                // player.angle.current = player.angle.target;\r\n                // player.angle.target = measure;\r\n            }\r\n        }\r\n        /** Update angle when attacking. */\r\n        if (player.attack.attacking.server) {\r\n            player.angle.current = player.angle.target;\r\n            player.attack.mouse = Math.atan2(this.mouse.y - (this.canvas.height / 2), this.mouse.x - (this.canvas.width / 2));\r\n            const weapon = Definitions_1.Weapons[player.weapon];\r\n            let posRange = player.attack.mouse + weapon.range;\r\n            let negRange = player.attack.mouse - weapon.range;\r\n            if (posRange > Math.PI)\r\n                posRange -= Functions_1.TAU;\r\n            if (negRange < -Math.PI)\r\n                negRange += Functions_1.TAU;\r\n            // TODO(Altanis): Fix lerpAngle fucktion.\r\n            const angle = (0, Functions_1.lerpAngle)(posRange, negRange, player.attack.lerpFactor);\r\n            player.attack.lerpFactor += 5 * (weapon.speed / 1000) * player.attack.direction;\r\n            if (player.attack.lerpFactor >= 1 || player.attack.lerpFactor <= 0) {\r\n                player.attack.direction *= -1;\r\n                if (++player.attack.cycles % 2 === 0) {\r\n                    player.attack.attacking.server = player.attack.attacking.change;\r\n                }\r\n            }\r\n            player.angle.target = angle;\r\n        }\r\n        /** Check for when to send an ATTACK packet. */\r\n        if (player.attack.attacking.client !== player.attack.attacking.server) {\r\n            this.client.connection.send(Enums_1.ServerBound.Attack, {\r\n                isAtk: player.attack.attacking.client\r\n            });\r\n        }\r\n        requestAnimationFrame(this.loop.bind(this));\r\n    }\r\n}\r\nexports[\"default\"] = ElementManager;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Rendering/ElementManager.ts?");

/***/ }),

/***/ "./views/client/Rendering/ImageManager.ts":
/*!************************************************!*\
  !*** ./views/client/Rendering/ImageManager.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst Config_1 = __webpack_require__(/*! ../Utils/Config */ \"./views/client/Utils/Config.ts\");\r\n/** Manages frames of an image when rendering so it looks like a GIF. */\r\nclass ImageManager {\r\n    constructor() {\r\n        /** All cached images. */\r\n        this.images = new Map(); // CharacterName => { frames: Images[], at: number }\r\n    }\r\n    /** The delay before switching to a new frame. */\r\n    /** Requests for the current frame of an image. */\r\n    get(path, sharded = false) {\r\n        let data = this.images.get(path);\r\n        if (!data)\r\n            return this.request(path, sharded);\r\n        const image = data.frames[data.at];\r\n        /** @ts-ignore */\r\n        if (data.frames.length && sharded && ++data.delay > 2) {\r\n            data.at = ++data.at % data.frames.length;\r\n            data.delay = 0;\r\n        }\r\n        return image;\r\n    }\r\n    /** Requests for an image to be cached. */\r\n    request(path, sharded = false) {\r\n        this.images.set(path, {\r\n            at: 0,\r\n            frames: [],\r\n            delay: 0\r\n        });\r\n        if (sharded) {\r\n            for (let i = 0; i < Config_1.FRAME_COUNT; i++) {\r\n                const image = new Image();\r\n                image.src = `${path}${i + 1}.png`;\r\n                image.addEventListener(\"load\", () => {\r\n                    this.images.get(path).frames.push(image);\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            const image = new Image();\r\n            image.src = path + \".png\";\r\n            image.addEventListener(\"load\", () => {\r\n                this.images.get(path).frames.push(image);\r\n            });\r\n        }\r\n    }\r\n}\r\nexports[\"default\"] = ImageManager;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Rendering/ImageManager.ts?");

/***/ }),

/***/ "./views/client/Utils/Config.ts":
/*!**************************************!*\
  !*** ./views/client/Utils/Config.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FRAME_COUNT = exports.GRID_SIZE = exports.ARENA_SIZE = void 0;\r\n/** The size of the arena. */\r\nexports.ARENA_SIZE = 14400;\r\n/** The size of the grid boxes. */\r\nexports.GRID_SIZE = 100;\r\n/** The frame count of the characters. */\r\nexports.FRAME_COUNT = 8;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Utils/Config.ts?");

/***/ }),

/***/ "./views/client/Utils/Functions.ts":
/*!*****************************************!*\
  !*** ./views/client/Utils/Functions.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.constrain = exports.lerpAngle = exports.lerp = exports.randomRange = exports.TAU = void 0;\r\n/** TAU, 360 degrees or Math.PI * 2. */\r\nexports.TAU = Math.PI * 2;\r\n/** Returns a random number in between two numbers. */\r\nconst randomRange = (min, max) => Math.random() * (max - min) + min;\r\nexports.randomRange = randomRange;\r\n/** Linear interpolation for any type of integer. */\r\nconst lerp = (a, b, t) => a + (b - a) * t;\r\nexports.lerp = lerp;\r\n/** Linear interpolation for specifically angles. */\r\nconst lerpAngle = (a, b, t) => {\r\n    let value = a + (-((a - b + Math.PI * 3) % (exports.TAU) - Math.PI)) * t;\r\n    if (value > Math.PI)\r\n        value -= exports.TAU;\r\n    if (value < -Math.PI)\r\n        value += exports.TAU;\r\n    return value;\r\n};\r\nexports.lerpAngle = lerpAngle;\r\n/** Constrain a value between two values. */\r\nconst constrain = (min, value, max) => Math.max(Math.min(value, max), min);\r\nexports.constrain = constrain;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Utils/Functions.ts?");

/***/ }),

/***/ "./views/client/Utils/Logger.ts":
/*!**************************************!*\
  !*** ./views/client/Utils/Logger.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n/** A colorful logger to highlight important actions. */\r\nconst Logger = {\r\n    log: (...args) => console.log(`%c[${Date().split(\" \")[4]}]: ${args.join(\" \")}`, 'color: blue;'),\r\n    err: (...args) => console.log(`%c[${Date().split(\" \")[4]}]: ${args.join(\" \")}`, 'color: red;'),\r\n    success: (...args) => console.log(`%c[${Date().split(\" \")[4]}]: ${args.join(\" \")}`, 'color: green;'),\r\n    warn: (...args) => console.log(`%c[${Date().split(\" \")[4]}]: ${args.join(\" \")}`, 'color: yellow;'),\r\n    debug: (...args) => console.log(args.join(\" \"))\r\n};\r\nexports[\"default\"] = Logger;\r\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Utils/Logger.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./views/client/Index.ts");
/******/ 	
/******/ })()
;