/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./views/client/Client.ts":
/*!********************************!*\
  !*** ./views/client/Client.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Connection_1 = __importDefault(__webpack_require__(/*! ./Connection/Connection */ \"./views/client/Connection/Connection.ts\"));\nconst Logger_1 = __importDefault(__webpack_require__(/*! ./Utils/Logger */ \"./views/client/Utils/Logger.ts\"));\nconst ElementManager_1 = __importDefault(__webpack_require__(/*! ./Rendering/ElementManager */ \"./views/client/Rendering/ElementManager.ts\"));\nconst CanvasManager_1 = __importDefault(__webpack_require__(/*! ./Rendering/CanvasManager */ \"./views/client/Rendering/CanvasManager.ts\"));\nconst Player_1 = __importDefault(__webpack_require__(/*! ./Entity/Player */ \"./views/client/Entity/Player.ts\"));\n/** A representation of the client currently on the site. */\nclass Client {\n    constructor() {\n        /** The logging system in the IOStream. */\n        this.logger = Logger_1.default;\n        /** The player information of the client. */\n        this.player = new Player_1.default();\n        /** The connection between the client and the server. */\n        this.connection = new Connection_1.default(this, \"ws://localhost:8080\");\n        /** The DOM element manager. */\n        this.elements = new ElementManager_1.default(this);\n        /** The canvas on which the client draws on. */\n        this.canvas = new CanvasManager_1.default(this);\n    }\n}\nexports[\"default\"] = Client;\n;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Client.ts?");

/***/ }),

/***/ "./views/client/Connection/Connection.ts":
/*!***********************************************!*\
  !*** ./views/client/Connection/Connection.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst SwiftStream_1 = __importDefault(__webpack_require__(/*! ./SwiftStream */ \"./views/client/Connection/SwiftStream.ts\"));\nconst Enums_1 = __webpack_require__(/*! ../Const/Enums */ \"./views/client/Const/Enums.ts\");\nconst MessageHandler_1 = __importDefault(__webpack_require__(/*! ./MessageHandler */ \"./views/client/Connection/MessageHandler.ts\"));\n/** A representation of the WebSocket connection between the client and the server. */\nclass Connection extends EventTarget {\n    constructor(client, url) {\n        super();\n        /** The amount of retries attempted. */\n        this.retries = 0;\n        /** The binary encoder/decoder for the connection. */\n        this.SwiftStream = new SwiftStream_1.default();\n        /** The handler for incoming messages. */\n        this.MessageHandler = new MessageHandler_1.default(this);\n        /** The latency of the player. */\n        this.latency = 0;\n        /** The timestamp the last ping packet was received. */\n        this.lastPing = 0;\n        this.client = client;\n        this.socket = new WebSocket(url);\n        this.socket.binaryType = \"arraybuffer\";\n        this.handle();\n    }\n    migrate(url) {\n        if (++this.retries > 3)\n            return this.client.logger.err(\"[WS]: Threshold for retries has been exceeded. Please reload.\");\n        this.socket.close(4999);\n        this.socket = new WebSocket(url);\n        this.socket.binaryType = \"arraybuffer\";\n        this.handle();\n    }\n    send(header, data) {\n        if (this.socket.readyState !== WebSocket.OPEN\n            || (!this.client.player.alive && header !== Enums_1.ServerBound.Spawn))\n            return;\n        this.SwiftStream.WriteI8(header);\n        switch (header) {\n            case Enums_1.ServerBound.Spawn: {\n                this.socket.send(this.SwiftStream\n                    .WriteCString(data.name)\n                    .WriteI8(this.client.player.character)\n                    .WriteI8(this.client.player.ability)\n                    .Write());\n                break;\n            }\n            case Enums_1.ServerBound.Movement: {\n                data.keys.forEach((key) => this.SwiftStream.WriteI8(key));\n                this.socket.send(this.SwiftStream.Write());\n                break;\n            }\n            case Enums_1.ServerBound.Angle: {\n                this.socket.send(this.SwiftStream.WriteFloat32(data.measure).Write());\n                break;\n            }\n            case Enums_1.ServerBound.Attack: {\n                this.socket.send(this.SwiftStream.WriteI8(data.isAtk).Write());\n                break;\n            }\n            default: {\n                this.SwiftStream.Write();\n                throw new Error(\"Could not find header. \" + header);\n            }\n        }\n    }\n    handle() {\n        this.socket.addEventListener(\"open\", () => {\n            this.client.logger.success(\"[WS]: Connected to server.\");\n        });\n        this.socket.addEventListener(\"error\", () => {\n            this.client.logger.err(\"[WS]: Connection to server has failed.\");\n            this.migrate(this.socket.url);\n        });\n        this.socket.addEventListener(\"close\", event => {\n            console.log(event.code);\n            if (event.code === 4999)\n                return; // Internal migration code.\n            this.client.elements.homescreen.homescreen.style.display =\n                this.client.elements.arena.game.style.display = \"none\";\n            this.client.canvas.phase = Enums_1.Phases.Homescreen;\n            this.client.elements.disconnect.disconnect.style.display = \"block\";\n            this.client.logger.err(\n            /** @ts-ignore */\n            this.client.elements.disconnect.disconnectMessage.innerText = Enums_1.CloseEvents[event.code] || Enums_1.CloseEvents[3006]);\n        });\n        this.socket.addEventListener(\"message\", ({ data }) => {\n            if (data.byteLength === 0) { // Ping packet.\n                const old = this.lastPing;\n                this.lastPing = Date.now();\n                this.latency = this.lastPing - old;\n                this.client.elements.arena.ping.innerText = `${this.latency}ms localhost`;\n                return this.socket.send(new Uint8Array(0));\n            }\n            this.SwiftStream.Set(data = new Uint8Array(data));\n            this.parse();\n        });\n    }\n    parse() {\n        const SwiftStream = this.SwiftStream;\n        const header = SwiftStream.ReadI8();\n        switch (header) {\n            case Enums_1.ClientBound.Update:\n                this.MessageHandler.Update();\n                break;\n            default: {\n                this.SwiftStream.Clear();\n                throw new Error(\"Could not parse packet. \" + header);\n            }\n        }\n        this.SwiftStream.Clear();\n    }\n}\nexports[\"default\"] = Connection;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Connection/Connection.ts?");

/***/ }),

/***/ "./views/client/Connection/Helpers/UpdateParser.ts":
/*!*********************************************************!*\
  !*** ./views/client/Connection/Helpers/UpdateParser.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Enums_1 = __webpack_require__(/*! ../../Const/Enums */ \"./views/client/Const/Enums.ts\");\nconst Box_1 = __importDefault(__webpack_require__(/*! ../../Entity/Box */ \"./views/client/Entity/Box.ts\"));\nconst Player_1 = __importDefault(__webpack_require__(/*! ../../Entity/Player */ \"./views/client/Entity/Player.ts\"));\nconst Logger_1 = __importDefault(__webpack_require__(/*! ../../Utils/Logger */ \"./views/client/Utils/Logger.ts\"));\nconst SwiftStream_1 = __importDefault(__webpack_require__(/*! ../SwiftStream */ \"./views/client/Connection/SwiftStream.ts\"));\n/** TODO(Altanis): Fix update for surroundings. */\nclass UpdateParser {\n    constructor(connection) {\n        /** The packet being handled. */\n        this.packet = new SwiftStream_1.default();\n        /** The map which parses fields. */\n        /** @ts-ignore */\n        this.fieldMap = new Map([\n            [Enums_1.Fields.ID, (entity) => {\n                    const id = this.packet.ReadI8();\n                    entity.id = id;\n                }],\n            [Enums_1.Fields.Position, (entity) => {\n                    const x = this.packet.ReadFloat32();\n                    const y = this.packet.ReadFloat32();\n                    entity.position.target = { x, y };\n                }],\n            [Enums_1.Fields.Attacking, (entity) => {\n                    const attacking = this.packet.ReadI8() === 0x01;\n                    entity.attack.attacking.change = attacking;\n                    if (!entity.attack.attacking.server && entity.attack.attacking.change)\n                        entity.attack.attacking.server = true;\n                }],\n            [Enums_1.Fields.Weapons, (entity) => {\n                    const weapon = this.packet.ReadI8();\n                    entity.weapon = weapon;\n                }],\n            [Enums_1.Fields.FOV, (entity) => {\n                    const fov = this.packet.ReadFloat32();\n                    entity.fov = fov;\n                }],\n            [Enums_1.Fields.Dimensions, (entity) => {\n                    const width = this.packet.ReadFloat32();\n                    const height = this.packet.ReadFloat32();\n                    entity.dimensions = { width, height };\n                }],\n            [Enums_1.Fields.Alive, (entity) => {\n                    const alive = this.packet.ReadI8() === 0x01;\n                    entity.alive = alive;\n                    if (entity.id !== this.player.id)\n                        return;\n                    if (alive) {\n                        entity.lastAlive = Date.now();\n                        this.client.canvas.phase = Enums_1.Phases.Arena;\n                        this.client.elements.homescreen.homescreen.style.display = \"none\";\n                        this.client.elements.arena.stats.style.display =\n                            this.client.elements.arena.utils.style.display =\n                                this.client.canvas.mapCanvas.style.display = \"block\";\n                    }\n                    else {\n                        const time = new Date(Date.now() - entity.lastAlive);\n                        const hours = time.getUTCHours().toString().padStart(2, '0');\n                        const minutes = time.getUTCMinutes().toString().padStart(2, '0');\n                        const seconds = time.getUTCSeconds().toString().padStart(2, '0');\n                        setTimeout(() => this.client.elements.arena.death.style.display = \"flex\", 250);\n                        this.client.elements.arena.killedBy.innerHTML = `You were killed by $ex.`;\n                        this.client.elements.arena.timeAlive.innerHTML = `Time Alive: ${hours}h ${minutes}m ${seconds}s`;\n                    }\n                }],\n            [Enums_1.Fields.Angle, (entity) => {\n                    const angle = this.packet.ReadFloat32();\n                    entity.angle.target = angle;\n                }],\n            [Enums_1.Fields.Health, (entity) => {\n                    const health = this.packet.ReadI8();\n                    entity.health = health;\n                    if (entity.id === this.player.id)\n                        this.client.elements.update(\"health\", health);\n                }],\n            [Enums_1.Fields.Armor, (entity) => {\n                    const armor = this.packet.ReadI8();\n                    entity.armor = armor;\n                    if (entity.id === this.player.id)\n                        this.client.elements.update(\"armor\", armor);\n                }],\n            [Enums_1.Fields.Energy, (entity) => {\n                    const energy = this.packet.ReadI8();\n                    entity.energy = energy;\n                    if (entity.id === this.player.id)\n                        this.client.elements.update(\"energy\", energy);\n                }],\n            [Enums_1.Fields.Name, (entity) => {\n                    const name = this.packet.ReadCString();\n                    entity.name = name;\n                }],\n        ]);\n        this.connection = connection;\n        this.client = connection.client;\n        this.player = this.client.player;\n    }\n    parse(packet) {\n        this.packet = packet;\n        this.packet.ReadI8(); // Header\n        const group = this.nextGroup();\n        if (group === 0x00) {\n            const fieldLength = this.packet.ReadI8();\n            this.nextFields(fieldLength);\n        }\n        const surroundings = group !== 0x00 ? group : this.packet.ReadI8();\n        if (surroundings === 0x01) {\n            const entityLength = this.packet.ReadI8();\n            this.nextEntities(entityLength);\n        }\n        this.player.surroundings = this.player.surroundings.filter(entity => entity.updated);\n        this.player.surroundings.forEach(entity => entity.updated = false);\n    }\n    nextGroup() {\n        return this.packet.ReadI8();\n    }\n    nextFields(length, entity) {\n        for (; length--;) {\n            const field = this.packet.ReadI8();\n            const executor = this.fieldMap.get(field);\n            if (!executor)\n                Logger_1.default.err(`Unknown field ${field}!`);\n            else\n                executor(entity || this.player);\n        }\n    }\n    nextEntities(length) {\n        for (; length--;) {\n            const entity = this.packet.ReadI8();\n            const fieldLength = this.packet.ReadI8() - 1;\n            const IDField = this.packet.ReadI8();\n            const ID = this.packet.ReadI8();\n            let _entity = this.player.surroundings.find(entity => entity.id === ID);\n            if (!_entity) {\n                switch (entity) {\n                    case Enums_1.Entities.Player:\n                        _entity = new Player_1.default();\n                        break;\n                    case Enums_1.Entities.Box:\n                        _entity = new Box_1.default();\n                        break;\n                    default: Logger_1.default.err(`Unknown entity ${entity}!`);\n                }\n                _entity.type = entity;\n                _entity.id = ID;\n                this.player.surroundings.push(_entity);\n            }\n            _entity.updated = true;\n            this.nextFields(fieldLength, _entity);\n        }\n    }\n}\nexports[\"default\"] = UpdateParser;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Connection/Helpers/UpdateParser.ts?");

/***/ }),

/***/ "./views/client/Connection/MessageHandler.ts":
/*!***************************************************!*\
  !*** ./views/client/Connection/MessageHandler.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst SwiftStream_1 = __importDefault(__webpack_require__(/*! ./SwiftStream */ \"./views/client/Connection/SwiftStream.ts\"));\nconst UpdateParser_1 = __importDefault(__webpack_require__(/*! ./Helpers/UpdateParser */ \"./views/client/Connection/Helpers/UpdateParser.ts\"));\n/** A handler for all incoming messages. */\nclass MessageHandler {\n    constructor(connection) {\n        /** The update parser. */\n        this.UpdateParser = null;\n        this.connection = connection;\n    }\n    // Woah, that's a big packet!\n    Update() {\n        const SS = new SwiftStream_1.default();\n        SS.Set(this.connection.SwiftStream.buffer);\n        this.connection.SwiftStream.Clear();\n        if (!this.UpdateParser)\n            this.UpdateParser = new UpdateParser_1.default(this.connection);\n        this.UpdateParser.parse(SS);\n    }\n}\nexports[\"default\"] = MessageHandler;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Connection/MessageHandler.ts?");

/***/ }),

/***/ "./views/client/Connection/SwiftStream.ts":
/*!************************************************!*\
  !*** ./views/client/Connection/SwiftStream.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** BUFFERS: Used to convert between different byte lengths. */\nconst conversion = new ArrayBuffer(4);\nconst u8 = new Uint8Array(conversion);\nconst f32 = new Float32Array(conversion);\n/** SwiftStream, an efficient binary protocol manager written by Altanis. */\nclass SwiftStream {\n    constructor() {\n        /** The buffer SwiftStream is using. */\n        this.buffer = new Uint8Array(4096);\n        /** The position at which the buffer is being read. */\n        this.at = 0;\n        /** UTF8 Decoder. */\n        this.TextDecoder = new TextDecoder();\n        /** UTF8 Encoder. */\n        this.TextEncoder = new TextEncoder();\n    }\n    Set(buffer) {\n        this.buffer = buffer;\n        this.at = 0;\n    }\n    Clear() {\n        this.buffer = new Uint8Array(4096);\n        this.at = 0;\n    }\n    /** READER */\n    ReadI8() {\n        return this.buffer[this.at++];\n    }\n    ReadFloat32() {\n        u8.set(this.buffer.slice(this.at, this.at += 4));\n        return f32[0];\n    }\n    ReadCString() {\n        const start = this.at;\n        while (this.buffer[this.at++])\n            ;\n        return this.TextDecoder.decode(this.buffer.slice(start, this.at - 1));\n    }\n    /** WRITER */\n    WriteI8(value) {\n        this.buffer[this.at++] = value;\n        return this;\n    }\n    WriteFloat32(value) {\n        f32[0] = value;\n        this.buffer.set(u8, this.at);\n        this.at += 4;\n        return this;\n    }\n    WriteCString(value) {\n        this.buffer.set(this.TextEncoder.encode(value), this.at);\n        this.at += value.length;\n        this.buffer[this.at++] = 0;\n        return this;\n    }\n    Write() {\n        const result = this.buffer.subarray(0, this.at);\n        this.Clear();\n        return result;\n    }\n}\nexports[\"default\"] = SwiftStream;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Connection/SwiftStream.ts?");

/***/ }),

/***/ "./views/client/Const/Definitions.ts":
/*!*******************************************!*\
  !*** ./views/client/Const/Definitions.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Weapons = exports.Abilities = exports.Characters = void 0;\n/** Characters and all their necessary clientside data. */\nconst Characters = [\n    /** Knight */\n    {\n        name: \"Knight\",\n        stats: {\n            health: 7,\n            armor: 6,\n            energy: 250\n        },\n        abilities: [0, 1],\n        src: \"Knight.gif\",\n        speed: 5,\n    },\n    {\n        name: \"Priest\",\n        stats: {\n            health: 7,\n            armor: 6,\n            energy: 300\n        },\n        abilities: [1],\n        src: \"Priest.gif\",\n        speed: 5,\n    }\n];\nexports.Characters = Characters;\n/** Abilities, a specific property of characters. */\nconst Abilities = [\n    /** Dual Wield */\n    {\n        name: \"Dual Wield\",\n        description: \"Attack with double the power.\",\n        src: \"dual_wield.png\",\n    },\n    /** Charge */\n    {\n        name: \"Charge\",\n        description: \"Bash into a foe with your shield.\",\n        src: \"charge.png\",\n    }\n];\nexports.Abilities = Abilities;\n/** Weapons, objects used to attack. */\nconst Weapons = [\n    /** Rusty Blade */\n    {\n        name: \"Rusty Blade\",\n        type: \"melee\",\n        rarity: \"common\",\n        damage: 10,\n        range: Math.PI / 4,\n        speed: 30,\n        src: \"rusty_blade\",\n        offsetX: 0,\n        offsetY: 0\n    }\n];\nexports.Weapons = Weapons;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Const/Definitions.ts?");

/***/ }),

/***/ "./views/client/Const/Enums.ts":
/*!*************************************!*\
  !*** ./views/client/Const/Enums.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Movement = exports.Entities = exports.Fields = exports.ServerBound = exports.ClientBound = exports.Phases = exports.CloseEvents = void 0;\n/** Representation of possible reasons the connection was closed. */\nexports.CloseEvents = {\n    3000: \"The server has detected multiple connections by you. Please terminate any existing connections.\",\n    3001: \"The server is full.\",\n    3002: \"The server has detected a malformed request made by you. Please refresh.\",\n    3003: \"The server has detected that you are a banned player.\",\n    3006: \"An unknown error has occurred. Please refresh.\"\n};\n/** Representation of the phase canvas is rendering. */\nvar Phases;\n(function (Phases) {\n    Phases[Phases[\"Homescreen\"] = 0] = \"Homescreen\";\n    Phases[Phases[\"Arena\"] = 1] = \"Arena\";\n})(Phases = exports.Phases || (exports.Phases = {}));\n;\nvar ClientBound;\n(function (ClientBound) {\n    /** Tells the client of it's surroundings. */\n    ClientBound[ClientBound[\"Update\"] = 0] = \"Update\";\n})(ClientBound = exports.ClientBound || (exports.ClientBound = {}));\n;\nvar ServerBound;\n(function (ServerBound) {\n    /** Client tells the server they want to spawn. [string(name), i8(characterIdx), i8(abilityIdx)] */\n    ServerBound[ServerBound[\"Spawn\"] = 0] = \"Spawn\";\n    /** Client tells the server they want to move. [i8(Movement)] */\n    ServerBound[ServerBound[\"Movement\"] = 1] = \"Movement\";\n    /** The angle the player is facing, in radians. [f32(angle)] */\n    ServerBound[ServerBound[\"Angle\"] = 2] = \"Angle\";\n    /** Client tells the server they want to attack. */\n    ServerBound[ServerBound[\"Attack\"] = 3] = \"Attack\";\n    /** Client cheats (when given developer code). */\n    ServerBound[ServerBound[\"Cheats\"] = 255] = \"Cheats\";\n})(ServerBound = exports.ServerBound || (exports.ServerBound = {}));\n;\n/** Fields of the Update packet. */\nvar Fields;\n(function (Fields) {\n    /** The ID of the entity. */\n    Fields[Fields[\"ID\"] = 0] = \"ID\";\n    /** The position of the entity. */\n    Fields[Fields[\"Position\"] = 1] = \"Position\";\n    /** If the entity is attacking. */\n    Fields[Fields[\"Attacking\"] = 2] = \"Attacking\";\n    /** The weapon(s) of the player. */\n    Fields[Fields[\"Weapons\"] = 3] = \"Weapons\";\n    /** The resolution (FoV) of the entity. */\n    Fields[Fields[\"FOV\"] = 4] = \"FOV\";\n    /** The dimensions of the entity. */\n    Fields[Fields[\"Dimensions\"] = 5] = \"Dimensions\";\n    /** Whether or not the entity is alive. */\n    Fields[Fields[\"Alive\"] = 6] = \"Alive\";\n    /** The angle of the entity. */\n    Fields[Fields[\"Angle\"] = 7] = \"Angle\";\n    /** The health of the entity. */\n    Fields[Fields[\"Health\"] = 8] = \"Health\";\n    /** The armor of the entity. */\n    Fields[Fields[\"Armor\"] = 9] = \"Armor\";\n    /** The energy of the entity. */\n    Fields[Fields[\"Energy\"] = 10] = \"Energy\";\n    /** The name of the entity. */\n    Fields[Fields[\"Name\"] = 11] = \"Name\";\n})(Fields = exports.Fields || (exports.Fields = {}));\n;\n/** Object types. */\nvar Entities;\n(function (Entities) {\n    Entities[Entities[\"Player\"] = 0] = \"Player\";\n    Entities[Entities[\"Box\"] = 1] = \"Box\";\n})(Entities = exports.Entities || (exports.Entities = {}));\n/** Movement codes. */\nvar Movement;\n(function (Movement) {\n    Movement[Movement[\"Up\"] = 1] = \"Up\";\n    Movement[Movement[\"Right\"] = 2] = \"Right\";\n    Movement[Movement[\"Down\"] = 3] = \"Down\";\n    Movement[Movement[\"Left\"] = 4] = \"Left\";\n})(Movement = exports.Movement || (exports.Movement = {}));\n;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Const/Enums.ts?");

/***/ }),

/***/ "./views/client/Entity/Box.ts":
/*!************************************!*\
  !*** ./views/client/Entity/Box.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _Entity_1 = __importDefault(__webpack_require__(/*! ./_Entity */ \"./views/client/Entity/_Entity.ts\"));\nclass Box extends _Entity_1.default {\n    constructor() {\n        super(...arguments);\n        /** The dimensions of the box. */\n        this.dimensions = { width: 300, height: 300 };\n        this.name = \"Box\";\n        this.health = 100;\n        this.maxHealth = 100;\n    }\n    render(ctx, frame) {\n        this.ticks++;\n        const pos = this.lerpPosition(frame);\n        const { width, height } = this.dimensions;\n        ctx.fillStyle = \"red\";\n        ctx.fillRect(pos.x, pos.y, width, height);\n    }\n}\nexports[\"default\"] = Box;\n;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Entity/Box.ts?");

/***/ }),

/***/ "./views/client/Entity/Player.ts":
/*!***************************************!*\
  !*** ./views/client/Entity/Player.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Definitions_1 = __webpack_require__(/*! ../Const/Definitions */ \"./views/client/Const/Definitions.ts\");\nconst Config_1 = __webpack_require__(/*! ../Utils/Config */ \"./views/client/Utils/Config.ts\");\nconst _Entity_1 = __importDefault(__webpack_require__(/*! ./_Entity */ \"./views/client/Entity/_Entity.ts\"));\n/** A representation of a Player entity. */\nclass Player extends _Entity_1.default {\n    constructor() {\n        super(...arguments);\n        /** The character index of the player. */\n        this.character = 0;\n        /** The ability index of the player. */\n        this.ability = 0;\n        /** The weapon the player is holding. */\n        this.weapon = 0;\n        /** If the player is alive. */\n        this.alive = false;\n        /** The dimensions of the player. */\n        this.dimensions = { width: 300, height: 300 };\n        /** Attack information of the player. */\n        this.attack = {\n            /** Whether or not the player is attacking. */\n            attacking: {\n                /** The client-side state. */\n                client: false,\n                /** The server-side state. */\n                server: false,\n                /** Whether or not to change state. */\n                change: false\n            },\n            /** The direction of angle movement. */\n            direction: 1,\n            /** The mouse angle when attacking. */\n            mouse: 0,\n            /** The lerp factor at which the mouse should go in between [posRange, negRange]. */\n            lerpFactor: 0,\n            /** The amount of times the direction has been reversed. */\n            cycles: 0\n        };\n        /** The field of vision of the player. */\n        this.fov = 0.9;\n        /** The entities surrounding the player. */\n        this.surroundings = [];\n        /** The health of the player. */\n        this.health = this.maxHealth;\n        /** The armor of the player. */\n        this.armor = this.maxArmor;\n        /** The energy of the player. */\n        this.energy = this.maxEnergy;\n        /** Private rendering utils for bars. */\n        this.healthWidth = this.health;\n        this.armorWidth = this.armor;\n        this.energyWidth = this.energy;\n        this.name = \"an unnamed player\";\n        /** Death animation information for the character. */\n        this.deathAnim = {\n            phase: 0,\n            size: this.dimensions.height,\n            targetSize: this.dimensions.height * 1.5,\n            transparency: 0,\n            targetTransparency: 1,\n            ticks: 0,\n            targetTicks: 30\n        };\n        /** The last time the player was alive. */\n        this.lastAlive = 0;\n    }\n    /** The maximum health of the player. */\n    get maxHealth() {\n        return Definitions_1.Characters[this.character].stats.health;\n    }\n    ;\n    /** The maximum armor of the player. */\n    get maxArmor() {\n        return Definitions_1.Characters[this.character].stats.armor;\n    }\n    ;\n    /** The maximum energy of the player. */\n    get maxEnergy() {\n        return Definitions_1.Characters[this.character].stats.energy;\n    }\n    ;\n    /** Render another player onto the canvas. */\n    renderOther(manager, ctx, position, angle) {\n        this.ticks++;\n        if (!this.alive && this.deathAnim.phase === 0)\n            this.destroy(manager, position);\n        else if (this.deathAnim.phase === 1)\n            this.destroy(manager, position);\n        if (!this.alive)\n            return;\n        const c = Definitions_1.Characters[this.character];\n        const w = Definitions_1.Weapons[this.weapon];\n        if (angle > Math.PI)\n            angle = Math.PI - 0.01;\n        else if (angle < -Math.PI)\n            angle = -Math.PI + 0.01;\n        ctx.save();\n        const scaleX = (angle > Math.PI / 2 && angle < Math.PI) || (angle < -Math.PI / 2 && angle > -Math.PI) ? -1 : 1; // TODO(Altanis): Fix for attacking.\n        ctx.translate(position.x, position.y);\n        this.renderBars(ctx, manager);\n        ctx.scale(scaleX, 1);\n        /** Render character. */\n        const character = manager.ImageManager.get(`img/characters/frames/${c.name}/${c.name}`, true);\n        if (!character)\n            return;\n        ctx.drawImage(character, -150, -150, this.dimensions.width, this.dimensions.height);\n        /** Render weapon. */\n        const weapon = manager.ImageManager.get(`img/weapons/${w.src}`);\n        if (!weapon)\n            return;\n        if (scaleX === -1) {\n            if (angle > -Math.PI / 2 && angle < Math.PI) {\n                angle = Math.PI - angle;\n            }\n            else if (angle < -Math.PI / 2 && angle > -Math.PI) {\n                angle = Math.abs(angle + (Math.PI / 2)) - (Math.PI / 2);\n            }\n        }\n        ctx.rotate(angle);\n        ctx.drawImage(weapon, w.offsetX, w.offsetY, 200, 40);\n        ctx.restore();\n    }\n    /** Renders the player onto the canvas. */\n    render(manager, ctx, position, angle) {\n        this.ticks++;\n        if (!this.alive && this.deathAnim.phase === 0)\n            this.destroy(manager, position);\n        else if (this.deathAnim.phase === 1)\n            this.destroy(manager, position);\n        if (!this.alive)\n            return;\n        const c = Definitions_1.Characters[this.character];\n        const w = Definitions_1.Weapons[this.weapon];\n        if (angle > Math.PI)\n            angle = Math.PI - 0.01;\n        else if (angle < -Math.PI)\n            angle = -Math.PI + 0.01;\n        const scaleX = (angle > Math.PI / 2 && angle < Math.PI) || (angle < -Math.PI / 2 && angle > -Math.PI) ? -1 : 1; // TODO(Altanis): Fix for attacking.\n        ctx.translate(position.x, position.y);\n        this.renderBars(ctx, manager);\n        ctx.scale(scaleX, 1);\n        /** Render character. */\n        const character = manager.ImageManager.get(`img/characters/frames/${c.name}/${c.name}`, true);\n        if (!character)\n            return;\n        ctx.drawImage(character, -150, -150, this.dimensions.width, this.dimensions.height);\n        /** Render weapon. */\n        const weapon = manager.ImageManager.get(`img/weapons/${w.src}`);\n        if (!weapon)\n            return;\n        if (scaleX === -1) {\n            if (angle > -Math.PI / 2 && angle < Math.PI) {\n                angle = Math.PI - angle;\n            }\n            else if (angle < -Math.PI / 2 && angle > -Math.PI) {\n                angle = Math.abs(angle + (Math.PI / 2)) - (Math.PI / 2);\n            }\n        }\n        ctx.rotate(angle);\n        ctx.drawImage(weapon, w.offsetX, w.offsetY, 200, 40);\n        // TODO(Altanis): Create a blue tracer to illustrate the path of the sword.\n        ctx.restore();\n        /** Render position on the minimap. */\n        manager.mapCtx.fillStyle = \"#FFFFFF\";\n        const minimapX = position.x * manager.mapCanvas.width / Config_1.ARENA_SIZE;\n        const minimapY = position.y * manager.mapCanvas.height / Config_1.ARENA_SIZE;\n        manager.drawCircle(minimapX, minimapY, 2, manager.mapCtx);\n    }\n    destroy(manager, position) {\n        this.deathAnim.phase = 1;\n        const size = this.deathAnim.size + (((this.deathAnim.targetSize - this.deathAnim.size) / this.deathAnim.targetTicks) * this.deathAnim.ticks);\n        const transparency = ((this.deathAnim.targetTransparency - this.deathAnim.transparency) / this.deathAnim.targetTicks) * this.deathAnim.ticks;\n        const c = Definitions_1.Characters[this.character];\n        const character = manager.ImageManager.get(`img/characters/frames/${c.name}/${c.name}`, true);\n        if (!character)\n            return;\n        /** Set transparency of drawImage. */\n        manager.ctx.save();\n        manager.ctx.translate(position.x, position.y);\n        manager.ctx.globalAlpha = 1 - transparency;\n        manager.ctx.drawImage(character, -(size / 2), -(size / 2), size, size);\n        manager.ctx.restore();\n        if (++this.deathAnim.ticks >= this.deathAnim.targetTicks)\n            this.deathAnim.phase = 2;\n    }\n    renderBars(ctx, manager) {\n        /** Render health bar. */\n        if (this.health !== this.healthWidth) {\n            this.healthWidth += this.healthWidth < this.health ? 0.2 : -0.2;\n            // TODO(Altanis): Ensure they collide at some point.\n            if (this.healthWidth < this.health ?\n                this.healthWidth > this.health :\n                this.healthWidth < this.health)\n                this.healthWidth = this.health;\n        }\n        ctx.fillStyle = \"#3d3f43\";\n        manager.roundRect(-85, 200, 200, 20, 8);\n        ctx.fillStyle = \"#FD3B3B\"; // opponent is #cc5152\n        manager.roundRect(-85, 200, 200 * (this.healthWidth / this.maxHealth), 20, 7);\n        /** Render armor bar. */\n        if (this.armor !== this.armorWidth) {\n            this.armorWidth += this.armorWidth < this.armor ? 0.2 : -0.2;\n            // TODO(Altanis): Ensure they collide at some point.\n            if (this.armorWidth < this.armor ?\n                this.armorWidth > this.armor :\n                this.armorWidth < this.armor)\n                this.armorWidth = this.armor;\n        }\n        ctx.fillStyle = \"#3d3f43\";\n        manager.roundRect(-85, 225, 200, 20, 8);\n        ctx.fillStyle = \"#A8D657\"; // opponent is #cc5152\n        manager.roundRect(-85, 225, 200 * (this.armorWidth / this.maxArmor), 20, 7);\n        /** Render energy bar. */\n        if (this.energy !== this.energyWidth) {\n            this.energyWidth += this.energyWidth < this.energy ? 0.2 : -0.2;\n            // TODO(Altanis): Ensure they collide at some point.\n            if (this.energyWidth < this.energy ?\n                this.energyWidth > this.energy :\n                this.energyWidth < this.energy)\n                this.energyWidth = this.energy;\n        }\n        ctx.fillStyle = \"#3d3f43\";\n        manager.roundRect(-85, 250, 200, 20, 8);\n        ctx.fillStyle = \"#7300FF\"; // opponent is #cc5152\n        manager.roundRect(-85, 250, 200 * (this.energyWidth / this.maxEnergy), 20, 7);\n        /*ctx.fillStyle = \"#FFFFFF\";\n        ctx.font = \"12px Orbitron\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(`${this.health}/${this.maxHealth}`, 0, 215);\n        ctx.fillText(`${this.armor}/${this.maxArmor}`, 0, 240);\n        ctx.fillText(`${this.energy}/${this.maxEnergy}`, 0, 265);*/\n    }\n}\nexports[\"default\"] = Player;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Entity/Player.ts?");

/***/ }),

/***/ "./views/client/Entity/_Entity.ts":
/*!****************************************!*\
  !*** ./views/client/Entity/_Entity.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Functions_1 = __webpack_require__(/*! ../Utils/Functions */ \"./views/client/Utils/Functions.ts\");\nconst Config_1 = __webpack_require__(/*! ../Utils/Config */ \"./views/client/Utils/Config.ts\");\nclass Entity {\n    constructor() {\n        /** The ID of the entity. */\n        this.id = -1;\n        /** The position of the entity. */\n        this.position = {\n            current: { x: 0, y: 0 },\n            target: { x: 0, y: 0 },\n            /** The velocity of the player. */\n            velocity: {\n                current: { x: 0, y: 0 },\n                target: { x: 0, y: 0 }\n            }\n        };\n        /** The angle of the entity. */\n        this.angle = {\n            current: 0,\n            target: 0,\n            /** Interpolation factor. */\n            factor: 0\n        };\n        /** The name of the entity. */\n        this.name = \"\";\n        /** Disable lerp for the entity (initial frame when seen). */\n        this.noLerp = true;\n        /** If the entity was updated last tick. */\n        this.updated = false;\n        /** The dimensions of the player. */\n        this.dimensions = { width: 0, height: 0 };\n        /** Ticks since the entity was created. */\n        this.ticks = 0;\n        /** The type of entity. */\n        this.type = 0;\n    }\n    lerpPosition(deltaTick) {\n        if (this.ticks <= 2)\n            return this.position.current = this.position.target;\n        this.position.current.x = (0, Functions_1.lerp)(this.position.current.x, this.position.target.x, 0.1 * deltaTick);\n        this.position.current.y = (0, Functions_1.lerp)(this.position.current.y, this.position.target.y, 0.1 * deltaTick);\n        this.position.current.x = (0, Functions_1.constrain)(0, this.position.current.x, Config_1.ARENA_SIZE);\n        this.position.current.y = (0, Functions_1.constrain)(0, this.position.current.y, Config_1.ARENA_SIZE);\n        /** @ts-ignore */\n        this.position.velocity.current.x = (0, Functions_1.lerp)(this.position.velocity.current.x, this.position.velocity.target.x, 0.01 * deltaTick);\n        /** @ts-ignore */\n        this.position.velocity.current.y = (0, Functions_1.lerp)(this.position.velocity.current.y, this.position.velocity.target.y, 0.01 * deltaTick);\n        return this.position.current;\n    }\n    lerpAngle(deltaTIck) {\n        if (this.ticks <= 2)\n            return this.angle.current = this.angle.target;\n        this.angle.current = (0, Functions_1.lerpAngle)(this.angle.current, this.angle.target, 0.35 * deltaTIck);\n        this.angle.current = (0, Functions_1.constrain)(-Math.PI, this.angle.current, Math.PI);\n        return this.angle.current;\n    }\n    render(...args) { }\n    ;\n    destroy(manager, ...args) { }\n    ;\n}\nexports[\"default\"] = Entity;\n;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Entity/_Entity.ts?");

/***/ }),

/***/ "./views/client/Index.ts":
/*!*******************************!*\
  !*** ./views/client/Index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Client_1 = __importDefault(__webpack_require__(/*! ./Client */ \"./views/client/Client.ts\"));\nconst Enums_1 = __webpack_require__(/*! ./Const/Enums */ \"./views/client/Const/Enums.ts\");\nconst client = new Client_1.default();\nconst KEYDOWN_MAP = new Map([\n    /** Movement keys. */\n    [38, 1],\n    [87, 1],\n    [39, 2],\n    [68, 2],\n    [40, 3],\n    [83, 3],\n    [37, 4],\n    [65, 4],\n]);\nclient.elements.canvas.addEventListener('contextmenu', event => event.preventDefault());\ndocument.addEventListener(\"keydown\", function (event) {\n    switch (event.code) {\n        case \"Enter\": {\n            if ( /** activeElement === NameInput && */client.elements.homescreen.play.style.display === \"block\") {\n                client.elements.homescreen.play.click();\n            }\n            break;\n        }\n    }\n    const key = KEYDOWN_MAP.get(event.which || event.keyCode);\n    if (key) {\n        client.elements.activeKeys.add(key);\n        switch (key) {\n            case Enums_1.Movement.Right:\n                client.player.position.velocity.target.x = 30;\n                break;\n            case Enums_1.Movement.Left:\n                client.player.position.velocity.target.x = -30;\n                break;\n            case Enums_1.Movement.Up:\n                client.player.position.velocity.target.y = -30;\n                break;\n            case Enums_1.Movement.Down:\n                client.player.position.velocity.target.y = 30;\n                break;\n        }\n        /*switch (key) {\n            case Movement.Right: client.player.position.velocity.target.x = Characters[client.player.character].speed; break;\n            case Movement.Left: client.player.position.velocity.target.x = -Characters[client.player.character].speed; break;\n            case Movement.Up: client.player.position.velocity.target.y = -Characters[client.player.character].speed; break;\n            case Movement.Down: client.player.position.velocity.target.y = Characters[client.player.character].speed; break;\n        }*/\n        /*if (client.player.position.velocity.x === 0 && client.player.position.velocity.y === 0) {\n            switch (key) {\n                case Movement.Up: client.player.position.velocity.y = -Characters[client.player.character].speed; break;\n                case Movement.Right: client.player.position.velocity.x = Characters[client.player.character].speed; break;\n                case Movement.Down: client.player.position.velocity.y = Characters[client.player.character].speed; break;\n                case Movement.Left: client.player.position.velocity.x = -Characters[client.player.character].speed; break;\n            }\n        }*/\n        event.preventDefault();\n    }\n});\ndocument.addEventListener(\"keyup\", function (event) {\n    const key = KEYDOWN_MAP.get(event.which || event.keyCode);\n    if (key) {\n        client.elements.activeKeys.delete(key);\n        switch (key) {\n            case Enums_1.Movement.Up:\n                client.player.position.velocity.target.y = 0;\n                break;\n            case Enums_1.Movement.Right:\n                client.player.position.velocity.target.x = 0;\n                break;\n            case Enums_1.Movement.Down:\n                client.player.position.velocity.target.y = 0;\n                break;\n            case Enums_1.Movement.Left:\n                client.player.position.velocity.target.x = 0;\n                break;\n        }\n        event.preventDefault();\n    }\n});\ndocument.addEventListener(\"mousemove\", function (event) {\n    client.elements.mouse = {\n        x: event.clientX,\n        y: event.clientY\n    };\n});\nclient.elements.canvas.addEventListener(\"mousedown\", function (event) {\n    if (client.canvas.phase === Enums_1.Phases.Arena)\n        client.player.attack.attacking.client = true;\n    event.preventDefault();\n});\nclient.elements.canvas.addEventListener(\"mouseup\", function (event) {\n    if (client.canvas.phase === Enums_1.Phases.Arena)\n        client.player.attack.attacking.client = false;\n    event.preventDefault();\n});\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Index.ts?");

/***/ }),

/***/ "./views/client/Rendering/CanvasManager.ts":
/*!*************************************************!*\
  !*** ./views/client/Rendering/CanvasManager.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Enums_1 = __webpack_require__(/*! ../Const/Enums */ \"./views/client/Const/Enums.ts\");\nconst Config_1 = __webpack_require__(/*! ../Utils/Config */ \"./views/client/Utils/Config.ts\");\nconst Functions_1 = __webpack_require__(/*! ../Utils/Functions */ \"./views/client/Utils/Functions.ts\");\nconst ImageManager_1 = __importDefault(__webpack_require__(/*! ./ImageManager */ \"./views/client/Rendering/ImageManager.ts\"));\n/** Psuedorandom number in between two ranges. */\n/** The canvas where nearly all visual representation is drawn. */\nclass CanvasManager {\n    constructor(client) {\n        /** CANVAS */\n        /** @ts-ignore */\n        this.canvas = document.getElementById(\"canvas\");\n        /** The context to draw on. */\n        this.ctx = this.canvas.getContext(\"2d\");\n        /** MAP CANVAS */\n        /** @ts-ignore */\n        this.mapCanvas = document.getElementById(\"mapDisplay\");\n        /** The context to draw on for the minimap. */\n        this.mapCtx = this.mapCanvas.getContext(\"2d\");\n        /** The phase in which rendering is occuring. */\n        this.phase = Enums_1.Phases.Homescreen;\n        /** The difference in between two frame renders. */\n        this.delta = 0;\n        /** The variable which keeps track of the last update. */\n        this.lastUpdate = 0;\n        /** The object which tracks FPS. */\n        this.FPS = {\n            fps: [0]\n        };\n        /** Manager for images. */\n        this.ImageManager = new ImageManager_1.default();\n        /** If the grid should be drawn. */\n        this.grid = true;\n        /** The stars on the homescreen. */\n        this.stars = {\n            count: 200,\n            stars: [],\n            radiusIncrement: 0.1\n        };\n        this.client = client;\n    }\n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.mapCtx.clearRect(0, 0, this.mapCanvas.width, this.mapCanvas.height);\n        this.delta = Date.now() - this.lastUpdate;\n        this.lastUpdate = Date.now();\n        switch (this.phase) {\n            case Enums_1.Phases.Homescreen:\n                this.Homescreen();\n                break;\n            case Enums_1.Phases.Arena:\n                this.Arena(this.delta);\n                break;\n        }\n    }\n    /** UTILITIES */\n    roundRect(x, y, w, h, r, ctx = this.ctx) {\n        if (w < 2 * r)\n            r = w / 2;\n        if (h < 2 * r)\n            r = h / 2;\n        /** @ts-ignore */\n        r = r - (r < 0) * r;\n        const xr = x + r, xw = x + w, yh = y + h;\n        ctx.beginPath();\n        ctx.moveTo(xr, y);\n        ctx.arcTo(xw, y, xw, yh, r);\n        ctx.arcTo(xw, yh, x, yh, r);\n        ctx.arcTo(x, yh, x, y, r);\n        ctx.arcTo(x, y, xw, y, r);\n        ctx.closePath();\n        ctx.fill();\n    }\n    drawCircle(x, y, r, ctx = this.ctx) {\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, Functions_1.TAU);\n        ctx.fill();\n    }\n    /** Renders the homescreen background (with pulsating stars). */\n    Homescreen() {\n        this.ctx.fillStyle = \"#000000\";\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = \"#FFFFFF\";\n        for (let i = this.stars.count - this.stars.stars.length; --i;) {\n            this.stars.stars.push({\n                x: (0, Functions_1.randomRange)(0, this.canvas.width),\n                y: (0, Functions_1.randomRange)(0, this.canvas.width),\n                radius: (0, Functions_1.randomRange)(0.1, 1.5),\n            });\n        }\n        for (let i = this.stars.stars.length; i--;) {\n            const star = this.stars.stars[i];\n            this.drawCircle(star.x, star.y, star.radius);\n            star.radius += this.stars.radiusIncrement;\n            if (star.radius >= 3)\n                this.stars.stars.splice(i, 1);\n        }\n    }\n    /** Renders the actual arena when spawned in. */\n    Arena(delta) {\n        /** Update FPS. */\n        if (this.FPS.fps.length > 30)\n            this.FPS.fps.shift();\n        this.FPS.fps.push(delta);\n        const deltaAverage = (this.FPS.fps.reduce((a, b) => a + b) / this.FPS.fps.length);\n        this.client.elements.arena.fps.innerText = (1000 / deltaAverage).toFixed(1) + '  FPS';\n        // RENDER OUTBOUNDS:\n        this.ctx.fillStyle = \"rgba(12, 50, 54, 1)\";\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.save();\n        const deltaTick = (0, Functions_1.constrain)(0, deltaAverage / 16.66, 1);\n        const pos = this.client.player.lerpPosition(deltaTick);\n        const angle = this.client.player.lerpAngle(deltaTick);\n        let { x: cameraX, y: cameraY } = pos;\n        /** Set up player camera. */\n        const factor = Math.min(this.canvas.width / 1080, this.canvas.height / 1920);\n        this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2); // Set <0, 0> to center.\n        this.ctx.scale(factor * this.client.player.fov, factor * this.client.player.fov);\n        this.ctx.translate(-cameraX + this.client.player.position.velocity.current.x, -cameraY + this.client.player.position.velocity.current.y);\n        // RENDER INBOUNDS:\n        this.ctx.strokeStyle = \"#2F8999\";\n        this.ctx.lineWidth = 10;\n        this.ctx.fillStyle = \"rgb(5,28,31)\";\n        this.ctx.strokeRect(0, 0, Config_1.ARENA_SIZE, Config_1.ARENA_SIZE);\n        this.ctx.fillRect(0, 0, Config_1.ARENA_SIZE, Config_1.ARENA_SIZE);\n        // RENDER GRID:\n        if (this.grid) {\n            this.ctx.strokeStyle = \"#334f52\";\n            this.ctx.lineWidth = 1;\n            for (let x = 0; x < Config_1.ARENA_SIZE; x += Config_1.GRID_SIZE) {\n                this.ctx.beginPath();\n                this.ctx.moveTo(x, 0);\n                this.ctx.lineTo(x, Config_1.ARENA_SIZE);\n                this.ctx.stroke();\n            }\n            for (let y = 0; y < Config_1.ARENA_SIZE; y += Config_1.GRID_SIZE) {\n                this.ctx.beginPath();\n                this.ctx.moveTo(0, y);\n                this.ctx.lineTo(Config_1.ARENA_SIZE, y);\n                this.ctx.stroke();\n            }\n        }\n        for (const entity of this.client.player.surroundings) {\n            switch (entity.type) {\n                case Enums_1.Entities.Box:\n                    entity.render(this.ctx, deltaTick);\n                    break;\n                /** @ts-ignore */\n                case Enums_1.Entities.Player:\n                    entity.renderOther(this, this.ctx, entity.lerpPosition(deltaTick), entity.lerpAngle(deltaTick));\n                    break;\n            }\n        }\n        this.client.player.render(this, this.ctx, pos, angle);\n        this.ctx.restore();\n    }\n}\nexports[\"default\"] = CanvasManager;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Rendering/CanvasManager.ts?");

/***/ }),

/***/ "./views/client/Rendering/ElementManager.ts":
/*!**************************************************!*\
  !*** ./views/client/Rendering/ElementManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Definitions_1 = __webpack_require__(/*! ../Const/Definitions */ \"./views/client/Const/Definitions.ts\");\nconst Enums_1 = __webpack_require__(/*! ../Const/Enums */ \"./views/client/Const/Enums.ts\");\nconst Functions_1 = __webpack_require__(/*! ../Utils/Functions */ \"./views/client/Utils/Functions.ts\");\n/** Manages DOM elements. */\nclass ElementManager {\n    constructor(client) {\n        /** Interactive elements on the homescreen. */\n        this.homescreen = {\n            /** The div which contains all elements of the homescreen. */\n            homescreen: document.getElementById(\"homescreen\"),\n            /** The button which spawns the player. */\n            play: document.getElementById(\"play\"),\n            /** The input where the name is held. */\n            // none yet\n            /** The div which holds all 3 gamemode buttons. */\n            gamemodes: document.getElementById(\"gamemodes\"),\n            /** The button to trigger the settings modal. */\n            settings: document.getElementById(\"settings\"),\n            /** The screen which displays when the client has disconnected. */\n            disconnect: document.getElementById(\"disconnect\"),\n            /** The div with the character selector. */\n            characterSelector: {\n                /** The left arrow for the character. */\n                arrowLeft: document.getElementById(\"arrow-left\"),\n                /** The right arrow for the character. */\n                arrowRight: document.getElementById(\"arrow-right\"),\n                /** The name of the character. */\n                characterName: document.getElementById(\"character-name\"),\n                /** The sprite of the character. */\n                characterSprite: document.getElementById(\"character-sprite\"),\n                /** The name of the ability. */\n                abilityName: document.getElementById(\"ability-name\"),\n                /** The description of the ability. */\n                abilityDesc: document.getElementById(\"ability-desc\"),\n                /** The selector icons of the abilities. */\n                abilitySelector: document.getElementById(\"ability\")\n            }\n        };\n        /** Toggleable settings. */\n        this.settings = {\n            /** The div which contains toggleable settings. */\n            settings: document.getElementById(\"settingsModal\"),\n            /** The setting to disable grid. */\n            hideGrid: document.getElementById(\"hideGrid\"),\n            /** Back button */\n            back: document.getElementById(\"back\")\n        };\n        /** Elements which display while playing. */\n        this.arena = {\n            /** The div containing all of these elements. */\n            game: document.getElementById(\"game\"),\n            /** The div which contains every stat of the player. */\n            stats: document.getElementById(\"stats\"),\n            /** The health bar in the stats div. */\n            health: document.getElementById(\"health\"),\n            /** The armor bar in the stats div. */\n            armor: document.getElementById(\"armor\"),\n            /** The energy bar in the stats div. */\n            energy: document.getElementById(\"energy\"),\n            /** The utils of the player, such as FPS/MS/Minimap. */\n            utils: document.getElementById(\"utils\"),\n            /** The name of the game. */\n            gameName: document.getElementById(\"gameName\"),\n            /** The FPS of the client. */\n            fps: document.getElementById(\"fps\"),\n            /** The ping of the client. */\n            ping: document.getElementById(\"ping\"),\n            /** The death screen when the player dies. */\n            death: document.getElementById(\"death\"),\n            /** The person who killed the player. */\n            killedBy: document.getElementById(\"killedBy\"),\n            /** The time alive. */\n            timeAlive: document.getElementById(\"timeAlive\"),\n        };\n        /** Elements which play when the player disconnects from the game. */\n        this.disconnect = {\n            /** The div which contains the disconnect message. */\n            disconnect: document.getElementById(\"disconnect\"),\n            /** The message displayed when disconnecting. */\n            disconnectMessage: document.getElementById(\"disconnect-message\")\n        };\n        /** The canvas to draw on. */\n        /** @ts-ignore */\n        this.canvas = document.getElementById(\"canvas\");\n        /** The keys currently being pressed. */\n        this.activeKeys = new Set();\n        /** The mouse coordinates of the client. */\n        this.mouse = { x: 0, y: 0 };\n        this.client = client;\n        this.setup();\n        this.loop();\n    }\n    setup() {\n        /** Add resize handlers for the canvas. */\n        window.addEventListener(\"resize\", () => {\n            this.canvas.height = window.innerHeight * window.devicePixelRatio;\n            this.canvas.width = window.innerWidth * window.devicePixelRatio;\n        });\n        window.dispatchEvent(new Event(\"resize\"));\n        /** Add stat texts. */\n        document.querySelectorAll(\".progress-bar\").forEach((p, i) => {\n            let name = \"\";\n            switch (i) {\n                case 0:\n                    name = \"health\";\n                    break;\n                case 1:\n                    name = \"armor\";\n                    break;\n                case 2:\n                    name = \"energy\";\n                    break;\n            }\n            name += \"Text\";\n            /** @ts-ignore */\n            this.arena[name] = p.children[1];\n        });\n        /** Create pointers for abilities and characters. */\n        this.homescreen.characterSelector.arrowLeft.addEventListener(\"click\", () => {\n            this.client.player.character = (this.client.player.character - 1 + Definitions_1.Characters.length) % Definitions_1.Characters.length;\n            this.client.player.ability = Definitions_1.Characters[this.client.player.character].abilities[0];\n        });\n        this.homescreen.characterSelector.arrowRight.addEventListener(\"click\", () => {\n            this.client.player.character = (this.client.player.character + 1) % Definitions_1.Characters.length;\n            this.client.player.ability = Definitions_1.Characters[this.client.player.character].abilities[0];\n        });\n        /** Send play signal to server when Play is pressed. */\n        this.homescreen.play.addEventListener(\"click\", () => {\n            this.client.connection.send(Enums_1.ServerBound.Spawn, {\n                name: \"Altanis\"\n            });\n            const { health, armor, energy } = Definitions_1.Characters[this.client.player.character].stats;\n            /** @ts-ignore */\n            this.arena.healthText.innerText = `${health}/${health}`;\n            /** @ts-ignore */\n            this.arena.armorText.innerText = `${armor}/${armor}`;\n            /** @ts-ignore */\n            this.arena.energyText.innerText = `${energy}/${energy}`;\n        });\n        /** Take settings into account. */\n        /** @ts-ignore */\n        // this.settings.hideGrid.checked = this.client.canvas.grid = localStorage.getItem(\"hideGrid\") === \"true\";\n        this.settings.hideGrid.addEventListener(\"change\", () => {\n            /** @ts-ignore */\n            localStorage.setItem(\"hideGrid\", this.settings.hideGrid.checked);\n            /** @ts-ignore */\n            this.client.canvas.grid = !this.settings.hideGrid.checked;\n        });\n        this.homescreen.settings.addEventListener(\"click\", () => {\n            this.settings.settings.style.display = \"flex\";\n            this.homescreen.homescreen.style.display = \"none\";\n        });\n        this.settings.back.addEventListener(\"click\", () => {\n            this.settings.settings.style.display = \"none\";\n            this.homescreen.homescreen.style.display = \"block\";\n        });\n    }\n    update(stat, target) {\n        const max = Definitions_1.Characters[this.client.player.character].stats[stat];\n        this.arena[stat + \"Text\"].innerText = `${target}/${max}`;\n        this.arena[stat].style.width = `${target / max * 100}%`;\n        this.client.player[stat] = target;\n    }\n    loop() {\n        var _a;\n        const player = this.client.player;\n        /** Update client's canvas. */\n        (_a = this.client.canvas) === null || _a === void 0 ? void 0 : _a.render();\n        /** Check if character has changed. */\n        let intuition = false;\n        const character = Definitions_1.Characters[player.character];\n        if (this.homescreen.characterSelector.characterName.innerText !== character.name) {\n            intuition = true;\n            this.homescreen.characterSelector.characterName.innerText = character.name;\n            /** @ts-ignore */\n            this.homescreen.characterSelector.characterSprite.src = `assets/img/characters/gifs/${character.src}`;\n        }\n        const playerAbility = Definitions_1.Abilities[player.ability];\n        if (this.homescreen.characterSelector.abilityName.innerHTML !== playerAbility.name || intuition) {\n            this.homescreen.characterSelector.abilityName.innerHTML = playerAbility.name;\n            this.homescreen.characterSelector.abilitySelector.innerHTML = \"\";\n            character.abilities.map(ability => Definitions_1.Abilities[ability]).forEach((ability, i) => {\n                const image = new Image(50, 50);\n                image.src = `assets/img/abilities/${ability.src}`;\n                image.classList.add(\"character-ability\");\n                if (ability.name === playerAbility.name) {\n                    this.homescreen.characterSelector.abilityDesc.innerText = ability.description;\n                    image.classList.add(\"selected\");\n                }\n                image.addEventListener(\"click\", () => {\n                    player.ability = character.abilities[i];\n                });\n                this.homescreen.characterSelector.abilitySelector.appendChild(image);\n            });\n        }\n        /** Recognize keypresses. */\n        if (this.activeKeys.size) {\n            this.client.connection.send(Enums_1.ServerBound.Movement, {\n                keys: this.activeKeys\n            });\n        }\n        /** Recognize mouse movements. */\n        if (this.mouse && player.alive && !player.attack.attacking.server) {\n            const old = player.angle.current;\n            const measure = Math.atan2(this.mouse.y - (this.canvas.height / 2), this.mouse.x - (this.canvas.width / 2));\n            if (old !== measure) {\n                this.client.connection.send(Enums_1.ServerBound.Angle, {\n                    measure\n                });\n                /*player.angle.current = player.angle.target;\n                player.angle.target = measure;*/\n            }\n        }\n        /** Update angle when attacking. */\n        if (player.attack.attacking.server) {\n            player.angle.current = player.angle.target;\n            player.attack.mouse = Math.atan2(this.mouse.y - (this.canvas.height / 2), this.mouse.x - (this.canvas.width / 2));\n            const weapon = Definitions_1.Weapons[player.weapon];\n            let posRange = player.attack.mouse + weapon.range;\n            let negRange = player.attack.mouse - weapon.range;\n            if (posRange > Math.PI)\n                posRange -= Functions_1.TAU;\n            if (negRange < -Math.PI)\n                negRange += Functions_1.TAU;\n            // TODO(Altanis): Fix lerpAngle fucktion.\n            const angle = (0, Functions_1.lerpAngle)(posRange, negRange, player.attack.lerpFactor);\n            player.attack.lerpFactor += 5 * (weapon.speed / 1000) * player.attack.direction;\n            if (player.attack.lerpFactor >= 1 || player.attack.lerpFactor <= 0) {\n                player.attack.direction *= -1;\n                if (++player.attack.cycles % 2 === 0) {\n                    player.attack.attacking.server = player.attack.attacking.change;\n                }\n            }\n            player.angle.target = angle;\n        }\n        /** Check for when to send an ATTACK packet. */\n        if (player.attack.attacking.client !== player.attack.attacking.server) {\n            this.client.connection.send(Enums_1.ServerBound.Attack, {\n                isAtk: player.attack.attacking.client\n            });\n        }\n        requestAnimationFrame(this.loop.bind(this));\n    }\n}\nexports[\"default\"] = ElementManager;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Rendering/ElementManager.ts?");

/***/ }),

/***/ "./views/client/Rendering/ImageManager.ts":
/*!************************************************!*\
  !*** ./views/client/Rendering/ImageManager.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Config_1 = __webpack_require__(/*! ../Utils/Config */ \"./views/client/Utils/Config.ts\");\n/** Manages frames of an image when rendering so it looks like a GIF. */\nclass ImageManager {\n    constructor() {\n        /** All cached images. */\n        this.images = new Map(); // CharacterName => { frames: Images[], at: number }\n    }\n    /** The delay before switching to a new frame. */\n    /** Requests for the current frame of an image. */\n    get(path, sharded = false) {\n        let data = this.images.get(path);\n        if (!data)\n            return this.request(path, sharded);\n        const image = data.frames[data.at];\n        /** @ts-ignore */\n        if (data.frames.length && sharded && ++data.delay > 4) {\n            data.at = ++data.at % data.frames.length;\n            data.delay = 0;\n        }\n        return image;\n    }\n    /** Requests for an image to be cached. */\n    request(path, sharded = false) {\n        this.images.set(path, {\n            at: 0,\n            frames: [],\n            delay: 0\n        });\n        if (sharded) {\n            for (let i = 0; i < Config_1.FRAME_COUNT; i++) {\n                const image = new Image();\n                image.src = `${path}${i + 1}.png`;\n                image.addEventListener(\"load\", () => {\n                    this.images.get(path).frames.push(image);\n                });\n            }\n        }\n        else {\n            const image = new Image();\n            image.src = path + \".png\";\n            image.addEventListener(\"load\", () => {\n                this.images.get(path).frames.push(image);\n            });\n        }\n    }\n}\nexports[\"default\"] = ImageManager;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Rendering/ImageManager.ts?");

/***/ }),

/***/ "./views/client/Utils/Config.ts":
/*!**************************************!*\
  !*** ./views/client/Utils/Config.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FRAME_COUNT = exports.GRID_SIZE = exports.ARENA_SIZE = void 0;\n/** The size of the arena. */\nexports.ARENA_SIZE = 14400;\n/** The size of the grid boxes. */\nexports.GRID_SIZE = 100;\n/** The frame count of the characters. */\nexports.FRAME_COUNT = 8;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Utils/Config.ts?");

/***/ }),

/***/ "./views/client/Utils/Functions.ts":
/*!*****************************************!*\
  !*** ./views/client/Utils/Functions.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.constrain = exports.lerpAngle = exports.lerp = exports.randomRange = exports.TAU = void 0;\n/** TAU, 360 degrees or Math.PI * 2. */\nexports.TAU = Math.PI * 2;\n/** Returns a random number in between two numbers. */\nconst randomRange = (min, max) => Math.random() * (max - min) + min;\nexports.randomRange = randomRange;\n/** Linear interpolation for any type of integer. */\nconst lerp = (a, b, t) => a + (b - a) * t;\nexports.lerp = lerp;\n/** Linear interpolation for specifically angles. */\nconst lerpAngle = (a, b, t) => {\n    let value = a + (-((a - b + Math.PI * 3) % (exports.TAU) - Math.PI)) * t;\n    if (value > Math.PI)\n        value -= exports.TAU;\n    if (value < -Math.PI)\n        value += exports.TAU;\n    return value;\n};\nexports.lerpAngle = lerpAngle;\n/** Constrain a value between two values. */\nconst constrain = (min, value, max) => Math.max(Math.min(value, max), min);\nexports.constrain = constrain;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Utils/Functions.ts?");

/***/ }),

/***/ "./views/client/Utils/Logger.ts":
/*!**************************************!*\
  !*** ./views/client/Utils/Logger.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** A colorful logger to highlight important actions. */\nconst Logger = {\n    log: (...args) => console.log(`%c[${Date().split(\" \")[4]}]: ${args.join(\" \")}`, 'color: blue;'),\n    err: (...args) => console.log(`%c[${Date().split(\" \")[4]}]: ${args.join(\" \")}`, 'color: red;'),\n    success: (...args) => console.log(`%c[${Date().split(\" \")[4]}]: ${args.join(\" \")}`, 'color: green;'),\n    warn: (...args) => console.log(`%c[${Date().split(\" \")[4]}]: ${args.join(\" \")}`, 'color: yellow;'),\n    debug: (...args) => console.log(args.join(\" \"))\n};\nexports[\"default\"] = Logger;\n\n\n//# sourceURL=webpack://valiant.io/./views/client/Utils/Logger.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./views/client/Index.ts");
/******/ 	
/******/ })()
;